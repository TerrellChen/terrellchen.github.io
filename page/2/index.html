<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Terrell Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/archives/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/13/Initial_Process_in_Log4j2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Terrell Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/Initial_Process_in_Log4j2/" class="post-title-link" itemprop="url">日志初始化流程(3)-Log4j2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-13 22:06:00" itemprop="dateCreated datePublished" datetime="2020-06-13T22:06:00+08:00">2020-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-28 00:23:50" itemprop="dateModified" datetime="2020-12-28T00:23:50+08:00">2020-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->

<ul>
<li><a href="#4-log4j-2%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B">4 Log4j 2加载流程</a><ul>
<li><a href="#41-loggercontext%E7%9A%84%E5%88%9B%E5%BB%BA">4.1 LoggerContext的创建</a><ul>
<li><a href="#42-loggercontext%E7%9A%84%E5%90%AF%E5%8A%A8">4.2 LoggerContext的启动</a></li>
<li><a href="#43-%E5%88%9B%E5%BB%BAloggerconfix-appender-configuration%E7%9A%84start-logger">4.3 创建LoggerConfix、Appender (Configuration的start())、Logger</a></li>
<li><a href="#44-%E6%80%BB%E7%BB%93">4.4 总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="4-log4j-2加载流程">4 Log4j 2加载流程</span></h2><p>Log4j2包名为org.apache.logging.log4j:log4j，与SLF4J整合使用需要引入其log4j-slf4j-impl模块。下面继续从StaticLoggerBinder开始分析</p>
<h3><span id="41-loggercontext的创建">4.1 LoggerContext的创建</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLoggerBinder</span> <span class="keyword">implements</span> <span class="title">LoggerFactoryBinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String REQUESTED_API_VERSION = <span class="string">&quot;1.6&quot;</span>; <span class="comment">// !final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGGER_FACTORY_CLASS_STR = Log4jLoggerFactory.class.getName();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticLoggerBinder SINGLETON = <span class="keyword">new</span> StaticLoggerBinder();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ILoggerFactory loggerFactory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">StaticLoggerBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loggerFactory = <span class="keyword">new</span> Log4jLoggerFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticLoggerBinder <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SINGLETON;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ILoggerFactory <span class="title">getLoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loggerFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getLoggerFactoryClassStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LOGGER_FACTORY_CLASS_STR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StaticLoggerBinder初始化过程中创建了一个Log4jLoggerFactory实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jLoggerFactory</span> <span class="keyword">extends</span> <span class="title">AbstractLoggerAdapter</span>&lt;<span class="title">Logger</span>&gt; <span class="keyword">implements</span> <span class="title">ILoggerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FQCN = Log4jLoggerFactory.class.getName();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PACKAGE = <span class="string">&quot;org.slf4j&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TO_SLF4J_CONTEXT = <span class="string">&quot;org.apache.logging.slf4j.SLF4JLoggerContext&quot;</span>;</span><br><span class="line">.......</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> LoggerContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; anchor = StackLocatorUtil.getCallerClass(FQCN, PACKAGE);</span><br><span class="line">    <span class="keyword">return</span> anchor == <span class="keyword">null</span> ? LogManager.getContext() : getContext(StackLocatorUtil.getCallerClass(anchor));</span><br><span class="line">  &#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Log4jLoggerFactory及其父类AbstractLoggerAdapter中并没有静态方法可以被触发，但在父类中实现了getLogger(name)方法。</p>
<p>还记得上文2.3部分的图一中有展示，整个在getILoggerFactory后会调用ILoggerFactory的getLogger方法。可以确认，log4j2的初始化流程从这里展开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> L <span class="title">getLogger</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取context，调用的就是上面贴出代码的getContext()方法</span></span><br><span class="line">  <span class="keyword">final</span> LoggerContext context = getContext();</span><br><span class="line">  <span class="keyword">final</span> ConcurrentMap&lt;String, L&gt; loggers = getLoggersInContext(context);</span><br><span class="line">  <span class="keyword">final</span> L logger = loggers.get(name);</span><br><span class="line">  <span class="keyword">if</span> (logger != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">  &#125;</span><br><span class="line">  loggers.putIfAbsent(name, newLogger(name, context));</span><br><span class="line">  <span class="keyword">return</span> loggers.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在getContext()中首次出现了LogManager的身影，查看LogManager.getContext()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggerContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.getContext(FQCN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IllegalStateException ex) &#123;</span><br><span class="line">    LOGGER.warn(ex.getMessage() + <span class="string">&quot; Using SimpleLogger&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleLoggerContextFactory().getContext(FQCN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的factory在LogManager的静态代码中初始化，简单介绍逻辑为从log4j-core的配置文件中获取factory的FQCN，通过反射创建对应实例。默认模式下，factory为org.apache.logging.log4j.core.impl.Log4jContextFactory。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.logging.log4j.core.impl.Log4jContextFactory 的 getContext方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoggerContext <span class="title">getContext</span><span class="params">(<span class="keyword">final</span> String fqcn, <span class="keyword">final</span> ClassLoader loader, <span class="keyword">final</span> Object externalContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> <span class="keyword">boolean</span> currentContext)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// selector 在反射创建 Log4jContextFactory 的过程中，被无参构造函数初始化</span></span><br><span class="line">  <span class="comment">// 这里默认初始化为 ClassLoaderContextSelector(另有AsyncLoggerContextSelector可配置)</span></span><br><span class="line">  <span class="comment">// 存在两种ctx: LoggerContext 及 AsyncLoggerContext</span></span><br><span class="line">  <span class="comment">// 两种ctx分别根据selector的类型确定，细节不详述了</span></span><br><span class="line">  <span class="keyword">final</span> LoggerContext ctx = selector.getContext(fqcn, loader, currentContext);</span><br><span class="line">  <span class="keyword">if</span> (externalContext != <span class="keyword">null</span> &amp;&amp; ctx.getExternalContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ctx.setExternalContext(externalContext);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ctx.getState() == LifeCycle.State.INITIALIZED) &#123;</span><br><span class="line">    <span class="comment">// 初始化！</span></span><br><span class="line">    ctx.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是对这一部分流程的汇总：</p>
<p><strong>初始化第一部分流程：从getLogger()到getContext()</strong></p>
<pre class="mermaid">sequenceDiagram
    participant LoggerFactory
    participant Log4jLoggerFactory
    participant LogManager
    participant Log4jContextFactory
    LoggerFactory ->>+ Log4jLoggerFactory: getLogger(name)
    Log4jLoggerFactory ->>+ LogManager: getContext()
    LogManager ->>+ Log4jContextFactory: getContext()
    Note right of LogManager: Log4jContextFactory<br>初始化于静态代码
    Log4jContextFactory ->>- LogManager: LoggerContext
    LogManager ->>- Log4jLoggerFactory: LoggerContext
    Log4jLoggerFactory ->>- LoggerFactory: Logger</pre>

<h4><span id="42-loggercontext的启动">4.2 LoggerContext的启动</span></h4><p>下面查看LoggerContext的start方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.logging.log4j.core.LoggerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOGGER.debug(<span class="string">&quot;Starting LoggerContext[name=&#123;&#125;, &#123;&#125;]...&quot;</span>, getName(), <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (PropertiesUtil.getProperties().getBooleanProperty(<span class="string">&quot;log4j.LoggerContext.stacktrace.on.start&quot;</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">    LOGGER.debug(<span class="string">&quot;Stack trace to locate invoker&quot;</span>,</span><br><span class="line">                 <span class="keyword">new</span> Exception(<span class="string">&quot;Not a real error, showing stack trace to locate invoker&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (configLock.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isInitialized() || <span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setStarting();</span><br><span class="line">        <span class="comment">// 走到这里终于即将读取配置</span></span><br><span class="line">        reconfigure();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.isShutdownHookEnabled()) &#123;</span><br><span class="line">          setUpShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setStarted();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      configLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LOGGER.debug(<span class="string">&quot;LoggerContext[name=&#123;&#125;, &#123;&#125;] started OK.&quot;</span>, getName(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reconfigure() -&gt; reconfigure(configurationLocation)</span></span><br><span class="line"><span class="comment">// 默认configurationLocation为null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconfigure</span><span class="params">(<span class="keyword">final</span> URI configURI)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line">  <span class="comment">// 获取configuration实例</span></span><br><span class="line">  <span class="keyword">final</span> Configuration instance = ConfigurationFactory.getInstance().getConfiguration(<span class="keyword">this</span>, contextName, configURI, cl);</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    LOGGER.error(<span class="string">&quot;Reconfiguration failed: No configuration found for &#x27;&#123;&#125;&#x27; at &#x27;&#123;&#125;&#x27; in &#x27;&#123;&#125;&#x27;&quot;</span>, contextName, configURI, cl);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 设置configuration</span></span><br><span class="line">    setConfiguration(instance);</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活并设置configuration</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">setConfiguration</span><span class="params">(<span class="keyword">final</span> Configuration config)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">    config.start();</span><br><span class="line">    <span class="keyword">this</span>.configuration = config;</span><br><span class="line">    updateLoggers();</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Configuration根据支持的配置类型分为四种：</p>
<ul>
<li>JsonConfigurationFactory -&gt; JsonConfiguration</li>
<li>PropertiesConfigurationFactory -&gt; PropertiesConfiguration</li>
<li>XMLConfigurationFactory -&gt; XMLConfiguration</li>
<li>YamlConfigurationFactory -&gt; YamlConfiguration</li>
</ul>
<p>在获取Configuration实例这部分也有非常多的工作，相关逻辑较为繁琐，先忽略。主要逻辑是：</p>
<ul>
<li>根据配置文件名生成对应的Configuration</li>
</ul>
<p>下面是对这一部分流程的汇总：</p>
<p><strong>初始化第二部分流程: Log4jContextFactory中getContext()的后续</strong></p>
<pre class="mermaid">sequenceDiagram
    participant Log4jContextFactory
    participant ContextSelector
    participant LoggerContext
    participant ConfigurationFactory
    participant Configuration
    Log4jContextFactory->>+ContextSelector: getContext()
    note right of Log4jContextFactory: ContextSelector<br>初始化于构造函数中
    ContextSelector->>-Log4jContextFactory: LoggerContext
    Log4jContextFactory->>+LoggerContext: start()
    LoggerContext->>LoggerContext: reconfigure()
    note right of LoggerContext: ConfigurationFactory<br>根据配置文件名<br>生成不同实例,如<br>XMLConfiguration
    LoggerContext->>+ConfigurationFactory: getConfiguration()
    ConfigurationFactory->>-LoggerContext: Configuration
    LoggerContext->>+Configuration: start()
    Configuration->>-LoggerContext: 
    LoggerContext->>-Log4jContextFactory: ;</pre>

<h4><span id="43-创建loggerconfix-appender-configuration的start-logger">4.3 创建LoggerConfix、Appender (Configuration的start())、Logger</span></h4><p>继续进入start方法内部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.logging.log4j.core.config.AbstractConfiguration</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Preserve the prior behavior of initializing during start if not initialized.</span></span><br><span class="line">  <span class="keyword">if</span> (getState().equals(State.INITIALIZING)) &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    initialize();</span><br><span class="line">  &#125;</span><br><span class="line">  LOGGER.debug(<span class="string">&quot;Starting configuration &#123;&#125;&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.setStarting();</span><br><span class="line">  <span class="keyword">if</span> (watchManager.getIntervalSeconds() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    watchManager.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hasAsyncLoggers()) &#123;</span><br><span class="line">    asyncLoggerConfigDisruptor.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Set&lt;LoggerConfig&gt; alreadyStarted = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> LoggerConfig logger : loggerConfigs.values()) &#123;</span><br><span class="line">    logger.start();</span><br><span class="line">    alreadyStarted.add(logger);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> Appender appender : appenders.values()) &#123;</span><br><span class="line">    appender.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!alreadyStarted.contains(root)) &#123; <span class="comment">// LOG4J2-392</span></span><br><span class="line">    root.start(); <span class="comment">// LOG4J2-336</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">super</span>.start();</span><br><span class="line">  LOGGER.debug(<span class="string">&quot;Started configuration &#123;&#125; OK.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在start中调用initialize()方法，对Configuration进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.logging.log4j.core.config.AbstractConfiguration</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化一些额外的插件</span></span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进行对配置进行一些构造</span></span><br><span class="line">  setup();</span><br><span class="line">  <span class="comment">// TODO 不知道干啥的，先忽略</span></span><br><span class="line">  setupAdvertisement();</span><br><span class="line">  <span class="comment">// 创建配置中的各种Logger appender对象</span></span><br><span class="line">  doConfigure();</span><br><span class="line">  setState(State.INITIALIZED);</span><br><span class="line">  LOGGER.debug(<span class="string">&quot;Configuration &#123;&#125; initialized&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doConfiguration()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConfigure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  			<span class="comment">// 遍历node检查类型是否合法</span></span><br><span class="line">        preConfigure(rootNode);</span><br><span class="line">        <span class="comment">// 创建好Logger(LoggerConfig) Appender, 然后将Appender插入LoggerConfig</span></span><br><span class="line">  			<span class="comment">// 这里的逻辑是遍历Node，先创建child，在创建parent</span></span><br><span class="line">  			<span class="comment">// 顶层的parent就是Appenders  Logger</span></span><br><span class="line">  			<span class="comment">// Appender是可输出内容的Appender，Logger只是LoggerConfig</span></span><br><span class="line">  			<span class="comment">// LoggerConfig在首次getLogger时才会实例化为Logger</span></span><br><span class="line">  			......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述初始化逻辑全部执行完毕后，继续回到getLogger的逻辑中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.logging.slf4j.Log4jLoggerFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> L <span class="title">getLogger</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> LoggerContext context = getContext();</span><br><span class="line">  <span class="keyword">final</span> ConcurrentMap&lt;String, L&gt; loggers = getLoggersInContext(context);</span><br><span class="line">  <span class="keyword">final</span> L logger = loggers.get(name);</span><br><span class="line">  <span class="keyword">if</span> (logger != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首次加载的时候logger时不存在的，调用newLogger方法</span></span><br><span class="line">  loggers.putIfAbsent(name, newLogger(name, context));</span><br><span class="line">  <span class="keyword">return</span> loggers.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Logger <span class="title">newLogger</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> LoggerContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String key = Logger.ROOT_LOGGER_NAME.equals(name) ? LogManager.ROOT_LOGGER_NAME : name;</span><br><span class="line">  <span class="comment">// 这里的validateContext对context进行了一次校验</span></span><br><span class="line">  <span class="comment">// 然后调用LoggerContext.getLogger尝试获取Logger</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Log4jLogger(markerFactory, validateContext(context).getLogger(key), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在LoggerContext中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.logging.log4j.core.LoggerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Logger <span class="title">getLogger</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> MessageFactory messageFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: This is the only method where we add entries to the &#x27;loggerRegistry&#x27; ivar.</span></span><br><span class="line">  Logger logger = loggerRegistry.getLogger(name, messageFactory);</span><br><span class="line">  <span class="keyword">if</span> (logger != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AbstractLogger.checkMessageFactory(logger, messageFactory);</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 到这里才首次对Logger进行创建</span></span><br><span class="line">  logger = newInstance(<span class="keyword">this</span>, name, messageFactory);</span><br><span class="line">  loggerRegistry.putIfAbsent(name, messageFactory, logger);</span><br><span class="line">  <span class="keyword">return</span> loggerRegistry.getLogger(name, messageFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是这部分的流程示意图</p>
<pre class="mermaid">sequenceDiagram
    participant Configuration
    participant AbstractConfiguration
    participant AsyncLoggerConfigDisruptor
    Configuration ->>+ AbstractConfiguration: initialize()
    AbstractConfiguration ->> AbstractConfiguration: setup()
    AbstractConfiguration ->> AbstractConfiguration: setupAdvertisement()
    AbstractConfiguration ->> AbstractConfiguration: doConfigure()
    note right of AbstractConfiguration: 循环初始化
    AbstractConfiguration ->> AsyncLoggerConfigDisruptor: start()
    AsyncLoggerConfigDisruptor ->> AbstractConfiguration: 
    AbstractConfiguration ->> AbstractConfiguration: 循环初始化</pre>

<ul>
<li>Configuration#start()<ul>
<li>AbstractConfiguration#initialize()<ul>
<li>AbstractConfiguration#setup()</li>
<li>AbstractConfiguration#setupAdvertisement()</li>
<li>AbstractConfiguration#doConfigure()<ul>
<li>Loop:<ul>
<li>init Properties</li>
<li>init Scripts</li>
<li>Init Appenders</li>
<li>init Loggers</li>
</ul>
</li>
<li>setToDefault()</li>
<li>Loop:<ul>
<li>LoggerConfig#addAppender()</li>
</ul>
</li>
<li>setParents()</li>
</ul>
</li>
<li>AsyncLoggerConfigDisruptor#start()</li>
<li>AbstractConfiguration.LoggerConfigs.foreach(lc -&gt; lc.start())</li>
<li>AbstractConfiguration.Appenders.foreach(appender -&gt; appender.start())</li>
<li>AbstractConfiguration.root.start()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><span id="44-总结">4.4 总结</span></h4><p>概述下整个流程：</p>
<ul>
<li>StaticLoggerBinder：创建Log4jLoggerFactory</li>
<li>LoggerFactory：getLogger触发Log4jLoggerFactory#getLogger</li>
<li>Log4jLoggerFactory：getLogger第一步尝试getContext，继续调用LogManager#getContext</li>
<li>LogManager：先执行静态方法，初始化LoggerContextFactory；</li>
<li>LoggerContextFactory：构造函数中创建ContextSelector；</li>
<li>LogManager：再执行getContext调用LoggerContextFactory#getContext</li>
<li>LoggerContextFactory：使用ContextSelector创建对应的LoggerContext；在调用LoggerContext#start</li>
<li>LoggerContext：先执行reconfigure，其中根据配置文件初始化了Configuration，并调用Configuration#start</li>
<li>Configuration：陆续调用initialize() -&gt; doConfigure()，在doConfigure()中完成对LoggerConfig、Appender的创建，即Appender于LoggerConfig的绑定</li>
<li>Log4jLoggerFactory：LoggerContext创建完毕后回到这个函数的getLogger，调用LoggerContext#getLogger</li>
<li>LoggerContext：首次getLogger时会创建Logger对象</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/06/Initial_Process_in_Log4j/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Terrell Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/Initial_Process_in_Log4j/" class="post-title-link" itemprop="url">日志初始化流程(2)-Log4j</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-06 19:30:00" itemprop="dateCreated datePublished" datetime="2020-06-06T19:30:00+08:00">2020-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-27 23:44:42" itemprop="dateModified" datetime="2020-12-27T23:44:42+08:00">2020-12-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->

<ul>
<li><a href="#3-log4j%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B">3 Log4j加载流程</a><ul>
<li><a href="#31-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A5%E5%8F%A3">3.1 初始化入口</a></li>
<li><a href="#32-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD">3.2 配置文件的加载</a><ul>
<li><a href="#321-xml%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">3.2.1 XML解析流程</a></li>
<li><a href="#322-properties%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">3.2.2 Properties解析流程</a></li>
</ul>
</li>
<li><a href="#33-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93">3.3 加载流程总结</a></li>
<li><a href="#34-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">3.4 生命周期</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="3-log4j加载流程">3 Log4j加载流程</span></h2><p>首先需要简单讲下Log4j如何与SLF4J整合使用，这里在代码中并不是直接引用log4j的包，而是引入slf4j-log4j12。slf4j-log4j12可以理解为为了让log4j能够接入SLF4J体系而做的桥接。下面要进行分析的StaticLoggerBinder也实现在slf4j-log4j12中。</p>
<h3><span id="31-初始化入口">3.1 初始化入口</span></h3><p>从slf4j-log4j12的StaticLoggerBinder开始入手过一遍流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLoggerBinder</span> <span class="keyword">implements</span> <span class="title">LoggerFactoryBinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量首先初始化，触发执行构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticLoggerBinder SINGLETON = <span class="keyword">new</span> StaticLoggerBinder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticLoggerBinder <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String REQUESTED_API_VERSION = <span class="string">&quot;1.6.99&quot;</span>; <span class="comment">// !final</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String loggerFactoryClassStr = Log4jLoggerFactory.class.getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ILoggerFactory loggerFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticLoggerBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建一个Log4jLoggerFactory</span></span><br><span class="line">        loggerFactory = <span class="keyword">new</span> Log4jLoggerFactory();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">            Level level = Level.TRACE;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldError nsfe) &#123;</span><br><span class="line">            Util.report(<span class="string">&quot;This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoggerFactory <span class="title">getLoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loggerFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoggerFactoryClassStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loggerFactoryClassStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jLoggerFactory</span> <span class="keyword">implements</span> <span class="title">ILoggerFactory</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 主要关注够构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Log4jLoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loggerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Logger&gt;();</span><br><span class="line">        <span class="comment">// force log4j to initialize</span></span><br><span class="line">        org.apache.log4j.LogManager.getRootLogger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 主要关注静态方法</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// By default we use a DefaultRepositorySelector which always returns &#x27;h&#x27;.</span></span><br><span class="line">    Hierarchy h = <span class="keyword">new</span> Hierarchy(<span class="keyword">new</span> RootLogger((Level) Level.DEBUG));</span><br><span class="line">    repositorySelector = <span class="keyword">new</span> DefaultRepositorySelector(h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Search for the properties file log4j.properties in the CLASSPATH.  */</span></span><br><span class="line">    String override =OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY,</span><br><span class="line">                                                       <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there is no default init override, then get the resource</span></span><br><span class="line">    <span class="comment">// specified by the user or the default config file.</span></span><br><span class="line">    <span class="keyword">if</span>(override == <span class="keyword">null</span> || <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(override)) &#123;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">// 尝试从配置项中获取配置文件路径</span></span><br><span class="line">      String configurationOptionStr = OptionConverter.getSystemProperty(</span><br><span class="line">        DEFAULT_CONFIGURATION_KEY, </span><br><span class="line">        <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      String configuratorClassName = OptionConverter.getSystemProperty(</span><br><span class="line">        CONFIGURATOR_CLASS_KEY, </span><br><span class="line">        <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      URL url = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the user has not specified the log4j.configuration</span></span><br><span class="line">      <span class="comment">// property, we search first for the file &quot;log4j.xml&quot; and then</span></span><br><span class="line">      <span class="comment">// &quot;log4j.properties&quot;</span></span><br><span class="line">      <span class="keyword">if</span>(configurationOptionStr == <span class="keyword">null</span>) &#123;	</span><br><span class="line">        <span class="comment">// 配置项没有配置的话尝试使用默认配置文件名 DEFAULT_XML_CONFIGURATION_FILE = log4j.xml</span></span><br><span class="line">        url = Loader.getResource(DEFAULT_XML_CONFIGURATION_FILE);</span><br><span class="line">        <span class="keyword">if</span>(url == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 第二个默认配置 DEFAULT_CONFIGURATION_FILE = log4j.properties</span></span><br><span class="line">          <span class="comment">// 这里就有个优先级问题了，同时存在的话看起来只有log4j.xml生效</span></span><br><span class="line">          url = Loader.getResource(DEFAULT_CONFIGURATION_FILE);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          url = <span class="keyword">new</span> URL(configurationOptionStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">          <span class="comment">// so, resource is not a URL:</span></span><br><span class="line">          <span class="comment">// attempt to get the resource from the class path</span></span><br><span class="line">          url = Loader.getResource(configurationOptionStr); </span><br><span class="line">        &#125;	</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we have a non-null url, then delegate the rest of the</span></span><br><span class="line">      <span class="comment">// configuration to the OptionConverter.selectAndConfigure</span></span><br><span class="line">      <span class="comment">// method.</span></span><br><span class="line">      <span class="keyword">if</span>(url != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LogLog.debug(<span class="string">&quot;Using URL [&quot;</span>+url+<span class="string">&quot;] for automatic log4j configuration.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 使用最终定位到配置文件的URL，进行配置加载</span></span><br><span class="line">          OptionConverter.selectAndConfigure(url, configuratorClassName,</span><br><span class="line">                                             LogManager.getLoggerRepository());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">          LogLog.warn(<span class="string">&quot;Error during default initialization&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LogLog.debug(<span class="string">&quot;Could not find resource: [&quot;</span>+configurationOptionStr+<span class="string">&quot;].&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LogLog.debug(<span class="string">&quot;Default initialization of overridden by &quot;</span> + </span><br><span class="line">                   DEFAULT_INIT_OVERRIDE_KEY + <span class="string">&quot;property.&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以很简单的分析出在被调用StaticLoggerBinder.getSingleton()方法后的执行顺序：</p>
<ul>
<li>初始化静态变量SINGLETON = new StaticLoggerBinder()</li>
<li>执行StaticLoggerBinder构造函数，创建一个Log4jLoggerFactory实例</li>
<li>执行Log4jLoggerFactory的构造函数，这里加载了org.apache.log4j.LogManager类</li>
<li>LogManager的静态代码块中尝试获取配置文件，并调用OptionConverter.selectAndConfigure进行加载</li>
</ul>
<h3><span id="32-配置文件的加载">3.2 配置文件的加载</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">org.apache.log4j.helpers.OptionConverter#selectAndConfigure(java.net.URL url, java.lang.String clazz, org.apache.log4j.spi.LoggerRepository LogManager.getLoggerRepository()) &#123;</span><br><span class="line">  Configurator configurator = <span class="keyword">null</span>;</span><br><span class="line">  String filename = url.getFile();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(clazz == <span class="keyword">null</span> &amp;&amp; filename != <span class="keyword">null</span> &amp;&amp; filename.endsWith(<span class="string">&quot;.xml&quot;</span>)) &#123;</span><br><span class="line">    clazz = <span class="string">&quot;org.apache.log4j.xml.DOMConfigurator&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里因为可能有配置项的clazz传入，所以不能直接断定是XML的DOMConfigurator进行new</span></span><br><span class="line">    LogLog.debug(<span class="string">&quot;Preferred configurator class: &quot;</span> + clazz);</span><br><span class="line">    configurator = (Configurator) instantiateByClassName(clazz,</span><br><span class="line">                                                         Configurator.class,</span><br><span class="line">                                                         <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span>(configurator == <span class="keyword">null</span>) &#123;</span><br><span class="line">      LogLog.error(<span class="string">&quot;Could not instantiate configurator [&quot;</span>+clazz+<span class="string">&quot;].&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    configurator = <span class="keyword">new</span> PropertyConfigurator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面确定了configurator，现在进行配置加载</span></span><br><span class="line">  configurator.doConfigure(url, hierarchy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在org.apache.log4j.helpers.OptionConverter#selectAndConfigure主要完成了配置项解析器的确定及实例化，并调用解析器对配置进行解析。</p>
<h4><span id="321-xml解析流程">3.2.1 XML解析流程</span></h4><p>在configurator.doConfigure(url, hierarchy)之后，经过一些简单逻辑，流程走到了parse方法这，此时repostory已经被赋值为刚才传入的参数hierarchy。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMConfigurator</span> <span class="keyword">implements</span> <span class="title">Configurator</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  LoggerRepository repository;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">    String rootElementName = element.getTagName();</span><br><span class="line">    <span class="comment">// 根据xml 检查版本</span></span><br><span class="line">    ......</span><br><span class="line">      <span class="comment">// 根据xml 是否开启debug</span></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//   reset repository before configuration if reset=&quot;true&quot;</span></span><br><span class="line">      <span class="comment">//       on configuration element.</span></span><br><span class="line">      <span class="comment">// TODO 不知道干啥的，先忽略</span></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据xml 设置日志级别</span></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Hashtable appenderBag = new Hashtable(11);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Building Appender objects, placing them in a local namespace</span></span><br><span class="line"><span class="comment">       for future reference */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// First configure each category factory under the root element.</span></span><br><span class="line">      <span class="comment">// Category factories need to be configured before any of</span></span><br><span class="line">      <span class="comment">// categories they support.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      String   tagName = <span class="keyword">null</span>;</span><br><span class="line">    Element  currentElement = <span class="keyword">null</span>;</span><br><span class="line">    Node     currentNode = <span class="keyword">null</span>;</span><br><span class="line">    NodeList children = element.getChildNodes();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = children.getLength();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历xml 优先解析categoryFactory</span></span><br><span class="line">    ......</span><br><span class="line">      <span class="keyword">if</span> (tagName.equals(CATEGORY_FACTORY_TAG) || tagName.equals(LOGGER_FACTORY_TAG)) &#123;</span><br><span class="line">        parseCategoryFactory(currentElement);</span><br><span class="line">      &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  再次遍历xml </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; length; loop++) &#123;</span><br><span class="line">        currentNode = children.item(loop);</span><br><span class="line">        <span class="keyword">if</span> (currentNode.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">          currentElement = (Element) currentNode;</span><br><span class="line">          tagName = currentElement.getTagName();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (tagName.equals(CATEGORY) || tagName.equals(LOGGER)) &#123;</span><br><span class="line">            <span class="comment">// 解析logger（category）</span></span><br><span class="line">            parseCategory(currentElement);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(ROOT_TAG)) &#123;</span><br><span class="line">            <span class="comment">// 解析root</span></span><br><span class="line">            parseRoot(currentElement);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tagName.equals(RENDERER_TAG)) &#123;</span><br><span class="line">            <span class="comment">// 解析对象渲染</span></span><br><span class="line">            parseRenderer(currentElement);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tagName.equals(THROWABLE_RENDERER_TAG)) &#123;</span><br><span class="line">            <span class="comment">// 解析异常渲染</span></span><br><span class="line">            <span class="keyword">if</span> (repository <span class="keyword">instanceof</span> ThrowableRendererSupport) &#123;</span><br><span class="line">              ThrowableRenderer tr = parseThrowableRenderer(currentElement);</span><br><span class="line">              <span class="keyword">if</span> (tr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ((ThrowableRendererSupport) repository).setThrowableRenderer(tr);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(tagName.equals(APPENDER_TAG)</span><br><span class="line">                       || tagName.equals(CATEGORY_FACTORY_TAG)</span><br><span class="line">                       || tagName.equals(LOGGER_FACTORY_TAG))) &#123;</span><br><span class="line">            <span class="comment">// 异常项</span></span><br><span class="line">            quietParseUnrecognizedElement(repository, currentElement, props);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 主要看logger及root，及它们的children是如何初始化的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析logger（创建）</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseCategory</span><span class="params">(Element loggerElement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new org.apache.log4j.Category object from the &lt;category&gt; element.</span></span><br><span class="line">    String catName = subst(loggerElement.getAttribute(NAME_ATTR));</span><br><span class="line">    Logger cat;</span><br><span class="line">    <span class="comment">// 获取logger class(默认不需要的)</span></span><br><span class="line">    String className = subst(loggerElement.getAttribute(CLASS_ATTR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据logger类（有的话）创建子类</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Setting up a category needs to be an atomic operation, in order</span></span><br><span class="line">      <span class="comment">// to protect potential log operations while category</span></span><br><span class="line">      <span class="comment">// configuration is in progress.</span></span><br><span class="line">      <span class="keyword">synchronized</span> (cat) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> additivity = OptionConverter.toBoolean(</span><br><span class="line">        subst(loggerElement.getAttribute(ADDITIVITY_ATTR)),</span><br><span class="line">        <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      LogLog.debug(<span class="string">&quot;Setting [&quot;</span> + cat.getName() + <span class="string">&quot;] additivity to [&quot;</span> + additivity + <span class="string">&quot;].&quot;</span>);</span><br><span class="line">      cat.setAdditivity(additivity);</span><br><span class="line">      <span class="comment">// 解析logger的关联的child，主要是appender</span></span><br><span class="line">      parseChildrenOfLoggerElement(loggerElement, cat, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析root</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseRoot</span><span class="params">(Element rootElement)</span> </span>&#123;</span><br><span class="line">    Logger root = repository.getRootLogger();</span><br><span class="line">    <span class="comment">// category configuration needs to be atomic</span></span><br><span class="line">    <span class="keyword">synchronized</span> (root) &#123;</span><br><span class="line">      <span class="comment">// 解析root关联的child</span></span><br><span class="line">      parseChildrenOfLoggerElement(rootElement, root, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 解析二级对象（主要从关联上来说的，一级就是logger root，二级就是被logger、root关联的appender</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseChildrenOfLoggerElement</span><span class="params">(Element catElement,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Logger cat, <span class="keyword">boolean</span> isRoot)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">      <span class="comment">// Remove all existing appenders from cat. They will be</span></span><br><span class="line">      <span class="comment">// reconstructed if need be.</span></span><br><span class="line">      cat.removeAllAppenders();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NodeList children = catElement.getChildNodes();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = children.getLength();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; length; loop++) &#123;</span><br><span class="line">      Node currentNode = children.item(loop);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currentNode.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">        Element currentElement = (Element) currentNode;</span><br><span class="line">        String tagName = currentElement.getTagName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(APPENDER_REF_TAG)) &#123;</span><br><span class="line">          <span class="comment">// 解析到是appender则创建</span></span><br><span class="line">          Element appenderRef = (Element) currentNode;</span><br><span class="line">          <span class="comment">// 查找或创建 appender</span></span><br><span class="line">          Appender appender = findAppenderByReference(appenderRef);</span><br><span class="line">          ......</span><br><span class="line">            <span class="comment">// logger关联上appender</span></span><br><span class="line">            cat.addAppender(appender);</span><br><span class="line">          .............</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          quietParseUnrecognizedElement(cat, currentElement, props);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// findAppenderByReference(appenderRef) 最终调用到 parseAppender(appenderElement)</span></span><br><span class="line">  <span class="comment">// appenderElement 为通过appender name 从 dom中找出来的element</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Appender <span class="title">parseAppender</span><span class="params">(Element appenderElement)</span> </span>&#123;</span><br><span class="line">    String className = subst(appenderElement.getAttribute(CLASS_ATTR));</span><br><span class="line">    LogLog.debug(<span class="string">&quot;Class name: [&quot;</span> + className + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据className创建一个appender实例</span></span><br><span class="line">      Object instance = Loader.loadClass(className).newInstance();</span><br><span class="line">      Appender appender = (Appender) instance;</span><br><span class="line">      PropertySetter propSetter = <span class="keyword">new</span> PropertySetter(appender);</span><br><span class="line"></span><br><span class="line">      appender.setName(subst(appenderElement.getAttribute(NAME_ATTR)));</span><br><span class="line"></span><br><span class="line">      NodeList children = appenderElement.getChildNodes();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> length = children.getLength();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; length; loop++) &#123;</span><br><span class="line">        Node currentNode = children.item(loop);</span><br><span class="line">        <span class="comment">/* We&#x27;re only interested in Elements */</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">          Element currentElement = (Element) currentNode;</span><br><span class="line">          <span class="comment">// Parse appender parameters</span></span><br><span class="line">          <span class="keyword">if</span> (currentElement.getTagName().equals(PARAM_TAG)) &#123;</span><br><span class="line">            setParameter(currentElement, propSetter);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Set appender layout</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (currentElement.getTagName().equals(LAYOUT_TAG)) &#123;</span><br><span class="line">            appender.setLayout(parseLayout(currentElement));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Add filters</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (currentElement.getTagName().equals(FILTER_TAG)) &#123;</span><br><span class="line">            parseFilters(currentElement, appender);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentElement.getTagName().equals(ERROR_HANDLER_TAG)) &#123;</span><br><span class="line">            parseErrorHandler(currentElement, appender);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentElement.getTagName().equals(APPENDER_REF_TAG)) &#123;</span><br><span class="line">            String refName = subst(currentElement.getAttribute(REF_ATTR));</span><br><span class="line">            <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> AppenderAttachable) &#123;</span><br><span class="line">              AppenderAttachable aa = (AppenderAttachable) appender;</span><br><span class="line">              LogLog.debug(<span class="string">&quot;Attaching appender named [&quot;</span> + refName +</span><br><span class="line">                           <span class="string">&quot;] to appender named [&quot;</span> + appender.getName() + <span class="string">&quot;].&quot;</span>);</span><br><span class="line">              aa.addAppender(findAppenderByReference(currentElement));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              LogLog.error(<span class="string">&quot;Requesting attachment of appender named [&quot;</span> +</span><br><span class="line">                           refName + <span class="string">&quot;] to appender named [&quot;</span> + appender.getName() +</span><br><span class="line">                           <span class="string">&quot;] which does not implement org.apache.log4j.spi.AppenderAttachable.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parseUnrecognizedElement(instance, currentElement, props);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 启动appender</span></span><br><span class="line">      propSetter.activate();</span><br><span class="line">      <span class="keyword">return</span> appender;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception oops) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InterruptedException || oops <span class="keyword">instanceof</span> InterruptedIOException) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">      LogLog.error(<span class="string">&quot;Could not create an Appender. Reported error follows.&quot;</span>,</span><br><span class="line">                   oops);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>在XML首先遍历Logger、Root等第一层级对象</li>
<li>根据Logger、Root关联的Appender-Ref，查找Appender配置，并创建Apender</li>
<li>关联Logger与Appender</li>
</ul>
<h4><span id="322-properties解析流程">3.2.2 Properties解析流程</span></h4><p>Properties解析流程与Xml类似，同样是第一层级对象优先解析生成，之后再创建第二层级对象并关联。</p>
<h3><span id="33-加载流程总结">3.3 加载流程总结</span></h3><p>从StaticLoggerBinder到解析配置文件</p>
 <pre class="mermaid">sequenceDiagram
    participant StaticLoggerBinder
    participant Log4jLoggerFactory
    participant LogManager
    participant OptionConverter
    participant Configurator 
    StaticLoggerBinder ->> StaticLoggerBinder: Constructor
    StaticLoggerBinder ->>+ Log4jLoggerFactory: Constructor
    Log4jLoggerFactory ->>+ LogManager: getRootLogger()
    LogManager ->> LogManager: run static code
    LogManager ->>+ OptionConverter: selectAndConfigure(url, clazz, repo)
    OptionConverter ->>+ Configurator: doConfigure(url, hierarchy);</pre>

<p>配置文件解析流程：</p>
<ul>
<li>遍历第一层级对象，如Logger、Root等</li>
<li>对Logger、Root中引用的child挨个初始化并关联至Logger或Root，如Appender等</li>
</ul>
<h3><span id="34-生命周期">3.4 生命周期</span></h3><p>在Log4j的设计中，Logger不存在生命周期，而Appender存在一个Active-Close的过程。</p>
<p>在配置文件解析过程中，Appender被创建，并被调用activeOption完成启动步骤（如打开文件，创建输出流等）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/31/An_IO_Issue_on_Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Terrell Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/An_IO_Issue_on_Linux/" class="post-title-link" itemprop="url">Linux下一次IO毛刺排查</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-31 17:04:00" itemprop="dateCreated datePublished" datetime="2020-05-31T17:04:00+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-27 23:41:23" itemprop="dateModified" datetime="2020-12-27T23:41:23+08:00">2020-12-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->

<ul>
<li><a href="#1-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF">1 问题背景</a></li>
<li><a href="#2-%E6%AF%9B%E5%88%BA%E7%9A%84%E5%8F%91%E7%8E%B0-io%E7%9B%91%E6%8E%A7">2 毛刺的发现-IO监控</a></li>
<li><a href="#3-%E8%84%8F%E9%A1%B5%E4%B8%8E%E5%86%99%E5%9B%9Edirty-page-writeback">3 脏页与写回(Dirty Page &amp; Writeback)</a></li>
<li><a href="#4-%E6%9B%B4%E5%BA%95%E5%B1%82%E7%9A%84%E7%9B%91%E6%8E%A7">4 更底层的监控</a></li>
<li><a href="#5-%E9%9C%87%E6%83%8Arocketmq%E7%AB%9F%E7%84%B6%E6%98%AF%E8%BF%99%E6%A0%B7%E5%88%B7%E7%9B%98%E7%9A%84">5 震惊，RocketMQ竟然是这样刷盘的</a></li>
<li><a href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%AF%9B%E5%88%BA">6 为什么会有毛刺</a></li>
<li><a href="#7-%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84writeback-%E8%BF%B7%E4%B9%8Bdirty_expire_centisecs">7 不均匀的Writeback-迷之dirty_expire_centisecs</a></li>
<li><a href="#8-%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88">8 优化方案</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-问题背景">1 问题背景</span></h2><p>排查RocketMQ的投递RT抖动问题，偶然发现生产环境的RocketMQ机器的写入耗时存在毛刺。由于暂时没有定位到投递RT抖动具体是磁盘IO导致还是网络IO导致，遂尝试先解决IO毛刺看问题能否恢复。下面分享下本次定位过程的思路和用到的工具。</p>
<p>先简单分享下结果，IO毛刺是系统writeback引起的。这个结果比较出我意料，因为在印象里，RocketMQ的所有文件，都有主动调用Flush，没道理轮到系统对脏页进行回收。</p>
<h2><span id="2-毛刺的发现-io监控">2 毛刺的发现-IO监控</span></h2><p>首先想到iostat，这是监控磁盘运行负载状况的一大利器。关于iostat的使用网上一搜一大把，就不再赘述。当然更推荐直接使用man去理解iostat，很多时候监控指标的精确定义是理解指标的关键。</p>
<p>在机器上使用iostat结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#iostat -xmt 1</span><br><span class="line">05&#x2F;31&#x2F;2020 02:22:54 AM</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.84    0.00    0.40    0.02    0.00   98.75</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rMB&#x2F;s    wMB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00  4255.00    0.00  591.00     0.00    32.26   111.80     0.03    0.05    0.00    0.05   0.05   2.70</span><br><span class="line"></span><br><span class="line">05&#x2F;31&#x2F;2020 02:22:55 AM</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.65    0.00    0.38    0.04    0.00   98.94</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rMB&#x2F;s    wMB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00  4618.00    0.00 1105.00     0.00    32.16    59.61     6.78    4.70    0.00    4.70   0.03   39.30</span><br><span class="line"></span><br><span class="line">05&#x2F;31&#x2F;2020 02:22:56 AM</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.58    0.00    0.36    0.04    0.00   99.02</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rMB&#x2F;s    wMB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00  4170.00    0.00  500.00     0.00    29.09   119.17     0.03    0.06    0.00    0.06   0.05   2.40</span><br><span class="line"></span><br><span class="line">05&#x2F;31&#x2F;2020 02:22:57 AM</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.77    0.00    0.33    0.02    0.00   98.87</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rMB&#x2F;s    wMB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00  4223.00    0.00  515.00     0.00    30.33   120.62     0.02    0.04    0.00    0.04   0.04   2.30</span><br><span class="line"></span><br><span class="line">05&#x2F;31&#x2F;2020 02:22:58 AM</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.71    0.00    0.38    0.04    0.00   98.87</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rMB&#x2F;s    wMB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00  4487.00    0.00  509.00     0.00    32.76   131.80     0.02    0.04    0.00    0.04   0.04   2.00</span><br><span class="line"></span><br><span class="line">05&#x2F;31&#x2F;2020 02:22:59 AM</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.09    0.00    0.38    0.04    0.00   98.50</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rMB&#x2F;s    wMB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00  4400.00    0.00  521.00     0.00    30.50   119.91     0.04    0.07    0.00    0.07   0.06   3.30</span><br><span class="line"></span><br><span class="line">05&#x2F;31&#x2F;2020 02:23:00 AM</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.63    0.00    0.38    0.06    0.00   98.94</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rMB&#x2F;s    wMB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00  4466.00    1.00  794.00     0.00    31.27    80.55     1.27    1.34    0.00    1.34   0.04   3.60</span><br><span class="line"></span><br><span class="line">05&#x2F;31&#x2F;2020 02:23:01 AM</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.79    0.00    0.46    0.13    0.00   98.62</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rMB&#x2F;s    wMB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00  5116.00    0.00 2630.00     0.00    43.98    34.24     0.09    0.03    0.00    0.03   0.03   8.30</span><br></pre></td></tr></table></figure>


<p><strong>w_await</strong></p>
<p>每5秒一次的w_await升高非常显眼，是首先需要关注的指标。关于w_await的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The average time (in milliseconds) for write requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.</span><br></pre></td></tr></table></figure>
<p>w_await辖内的时间既包括在请求队列中等待的时间，也包括硬件处理的时间。这个时间变长，意味着我们的IO耗时变长，也即是所谓的IO毛刺。</p>
<p><strong>%util</strong></p>
<p>util也是需要关注的指标，通常情况下，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Percentage  of  elapsed time during which I&#x2F;O requests were issued to the device (bandwidth utilization for the device). Device saturation occurs when this value is close to 100%.</span><br></pre></td></tr></table></figure>
<p>通常w_await变高，伴随着%util达到100%。这是一个很简单的关联逻辑，当磁盘负载满时，IO请求队列中的请求无法得到及时响应，w_await自然也就升高。这里的%util一次达到了39%，一次仅有3.6%，说明此时磁盘负载并没有完全爆满。</p>
<p>但是这里有一个需要注意点是iostat的统计时间。如果iostat每1秒输出一次，统计1秒内的数据，那么这里的%util意味着1秒内，块设备的负载情况并没有爆满，同时也保留了块设备在这1秒内的某一小段时间，如100ms的范围内，负载完全爆满的可能性。</p>
<p><strong>avgqu-sz</strong></p>
<p>直接上定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The average queue length of the requests that were issued to the device.</span><br></pre></td></tr></table></figure>
<p>设备请求队列平均长度，通常这个值超过经验值1，即说明磁盘无法及时处理完IO请求队列。这里一次达到6.14，一次是1.58，结合%util，基本可以确定，在统计的这1秒内的某一小段时间，设备负载是满的。</p>
<p><strong>w/s 与 wrqm/s</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrqm&#x2F;s</span><br><span class="line">The number of write requests merged per second that were queued to the device.</span><br><span class="line">w&#x2F;s</span><br><span class="line">The number (after merges) of write requests completed per second for the device.</span><br></pre></td></tr></table></figure>
<p>图中可以看到，写请求的数量有一个倍增，然而写合并的数量并没有变化。这里可以得到两个信息：写请求是周期性的，并且非常分散。</p>
<p><strong>此部分的总结</strong></p>
<p>到这里，我基本可以确定这里的IO写毛刺，是周期性（5s一次）的大量写请求导致的。根据我对RocketMQ代码的了解，其中并没有什么刷盘逻辑是5秒一次的，遂直接往系统怀疑。</p>
<p>系统周期性的IO，很自然的可以想到脏页的写回（Dirty Page Writeback）。下面将验证这一点。</p>
<h2><span id="3-脏页与写回dirty-page-amp-writeback">3 脏页与写回(Dirty Page &amp; Writeback)</span></h2><p>相信大家对Linux的内核子系统都有个大概的了解。在这里我简单总结下脏页与写回的概念：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了在CPU性能与块设备性能之间做平衡，引入了多级缓存的概念。将块设备中的文件，映射到内存中的某一段区域，对文件的修改即转化为对内存的修改，速度得以指数级提升。当然，这就涉及到何时将修改的内存写入到块设备中去的问题。</span><br><span class="line">显然，将一个文件映射的全部内存完整的覆盖到块设备中效率非常低下，那么对这部分内存空间进行逻辑上的切分，并且只将修改的部分写入块设备，显而易见是一个更好的方案。</span><br><span class="line">这里的缓存空间即被称作Page Cache，切分后的变成一页页Page，而其中被修改过的Page即是脏页。脏页需要被操作系统定期的更新至块设备中以防内存断电后数据丢失，更新的操作即是写回。</span><br></pre></td></tr></table></figure>
<p>关于脏页与写回，内核中有许多参数提供给用户配置，是用户具有调整其中部分逻辑的能力，完整的相关参数介绍可以见：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt%E3%80%82%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%8D%E4%BA%8E/proc/sys/vm/%E3%80%82">https://www.kernel.org/doc/Documentation/sysctl/vm.txt。配置文件位于/proc/sys/vm/。</a></p>
<p>说回上面5秒一次周期性IO毛刺，很显然首先需要关注的点是系统写回的频率，这个参数是dirty_writeback_centisecs（单位厘秒，这个参数具体是影响脏页周期性检查的间隔，详见上文链接）。查看该参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_writeback_centisecs</span><br><span class="line">500</span><br></pre></td></tr></table></figure>
<p>与5秒一次的周期完全吻合。为了验证是否是该参数导致的问题，我在这里试着将该参数调整为10秒，之后iostat中可见，毛刺的周期变为了10s一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo echo 1000 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_writeback_centisecs</span><br></pre></td></tr></table></figure>
<p>到这里，可以看出IO毛刺与Writeback是存在关联的。但是，奇怪的点也在这里，RocketMQ的主要文件包括CommitLog、IndexFile、ConsumeQueue，这所有的文件，印象中在代码里均有主动Flush逻辑，且间隔不超过1秒（后面的事实证明我在之前没有带着问题看代码的时候错过了一些细节^_^）。</p>
<p>为了找到（实锤）Writeback具体操作的哪些文件，我尝试对Writeback这一行为进行Debug。感谢内核在4.x之后存在（提供）了相应的工具，得以完成这一工作。</p>
<h2><span id="4-更底层的监控">4 更底层的监控</span></h2><p>万幸在做Java开发之前干过几天系统运维的工作，使我得以想到tracepoint这个linux 内核的基础设施。再次基础上经过一番资料查阅后，找到<strong>bpftrace</strong>及<strong>bcc</strong>这两个工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpftrace: https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bpftrace</span><br><span class="line">bcc: https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bcc</span><br></pre></td></tr></table></figure>
<p>对于这两个工具的具体细节暂时还不够水平也没有精力进行分析，在大多数情况下，根据其文档会用应该能满足非系统应用开发的需要了。关于安装和使用在主页中有对应文档，不再赘述。值得一提的是，这两个工具对Linux内核版本貌似要求4.x以上。</p>
<p>幸运的是，bpftrace在自带的工具中存在对writeback进程监控的脚本，在bcc的脚本中，我又找到了记录系统所有IO请求的脚本，下面来看两个工具的使用。</p>
<p><strong>bpftrace/writeback.bt-监控writeback的发生及耗时</strong></p>
<p>工具安装完成后使用非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;usr&#x2F;share&#x2F;bpftrace&#x2F;tools&#x2F;writeback.bt</span><br><span class="line">Attaching 4 probes...</span><br><span class="line">Tracing writeback... Hit Ctrl-C to end.</span><br><span class="line">TIME      DEVICE   PAGES    REASON           ms</span><br><span class="line">01:59:47  8:0      46702    periodic         0.590</span><br><span class="line">01:59:47  8:0      46702    periodic         0.000</span><br><span class="line">01:59:52  8:0      46965    periodic         100.305</span><br><span class="line">01:59:52  8:0      46965    periodic         0.002</span><br><span class="line">01:59:52  8:0      46965    periodic         0.000</span><br><span class="line">01:59:57  8:0      46917    periodic         0.729</span><br><span class="line">01:59:57  8:0      46917    periodic         0.000</span><br><span class="line">02:00:02  8:0      48674    periodic         82.553</span><br><span class="line">02:00:02  8:0      48674    periodic         0.000</span><br><span class="line">02:00:07  8:0      48224    periodic         0.791</span><br><span class="line">02:00:07  8:0      48224    periodic         0.000</span><br><span class="line">02:00:12  8:0      43899    periodic         77.174</span><br><span class="line">02:00:12  8:0      43899    periodic         0.000</span><br></pre></td></tr></table></figure>
<p>非常友好的输出，可以看出，定时任务(periodic)每5秒一次，会有一个巨大的延时，也是对应之前提到的IO毛刺。这里的REASON项，除了periodic之外，还可能有background等触发脏页写回的其他原因导致的启动。</p>
<p><strong>bcc/biosnoop.py-监控所有IO请求</strong></p>
<p>使用同样比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;usr&#x2F;share&#x2F;bcc&#x2F;tools&#x2F;biosnoop</span><br><span class="line">TIME(s)     COMM           PID    DISK    T SECTOR     BYTES  LAT(ms)</span><br><span class="line">0.000000    java           10958  sda     W 997907720  135168    0.07</span><br><span class="line">0.000212    jbd2&#x2F;sda5-8    1573   sda     W 1933891352 204800    0.07</span><br><span class="line">.......................</span><br><span class="line">1.906624    kworker&#x2F;u96:0  2406   sda     W 254486424  4096      0.22</span><br><span class="line">1.906639    kworker&#x2F;u96:0  2406   sda     W 284985880  4096      0.23</span><br><span class="line">.......................</span><br><span class="line">7.074782    kworker&#x2F;u96:0  2406   sda     W 759013280  4096      0.91</span><br><span class="line">7.074786    kworker&#x2F;u96:0  2406   sda     W 759013744  4096      0.91</span><br><span class="line">7.074789    kworker&#x2F;u96:0  2406   sda     W 759013800  4096      0.91</span><br><span class="line">.......................</span><br></pre></td></tr></table></figure>
<p>以执行命令开始的时间为基准进行累加，工具统计了接下来发生的所有IO请求的信息，包括顺序、发起的进程、IO类型、扇区、数据大小、耗时。</p>
<p>COMM一列下，kworker即是系统进程，这里的写入均可以认为是Writeback发起的。而根据IO请求的扇区我们即可拿到Writeback到底写了哪些文件。</p>
<p><strong>fdisk/debugfs-查询扇区对应文件</strong></p>
<p>这里通过四步步拿到扇区对应的文件：</p>
<ul>
<li>查询扇区所在设备</li>
<li>计算扇区Block</li>
<li>根据Block查询Inode</li>
<li>根据Inode查询文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#fdisk -l</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">&#x2F;dev&#x2F;sda1            2048        4095        1024   83  Linux</span><br><span class="line">&#x2F;dev&#x2F;sda2   *        4096   104861695    52428800   83  Linux</span><br><span class="line">&#x2F;dev&#x2F;sda3       104861696   125833215    10485760   82  Linux swap &#x2F; Solaris</span><br><span class="line">&#x2F;dev&#x2F;sda4       125833216  3748659199  1811412992    5  Extended</span><br><span class="line">&#x2F;dev&#x2F;sda5       125835264  3748659199  1811411968   83  Linux</span><br></pre></td></tr></table></figure>
<p>第一步使用fdisk命令可以拿到各设备的扇区范围，以SECTOR 254486424为例，它在/dev/sda5上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#expr \( 254486424 - 125835264 \) &#x2F; 8</span><br><span class="line">16081395</span><br></pre></td></tr></table></figure>
<p>第二步，计算器计算对应的Block，公式为（目标扇区-设备起始扇区）/ 8。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#debugfs &#x2F;dev&#x2F;sda5</span><br><span class="line">debugfs 1.42.9 (28-Dec-2013)</span><br><span class="line">debugfs:  icheck 16081395</span><br><span class="line">Block	Inode number</span><br><span class="line">16081395	33292549</span><br><span class="line">debugfs:  ncheck 33292549</span><br><span class="line">Inode	Pathname</span><br><span class="line">33292549	&#x2F;.............&#x2F;consumequeue&#x2F;............</span><br></pre></td></tr></table></figure>
<p>第三步第四步，使用debugfs，可以依次查询到block所属的inode，及inode对应的文件。至此，定位Writeback涉及到哪些文件的工作即完成了大半，剩下的即是查询所有出现过的请求中的扇区对应的文件了。</p>
<h2><span id="5-震惊rocketmq竟然是这样刷盘的">5 震惊，RocketMQ竟然是这样刷盘的</span></h2><p>这一小节与RocketMQ相关，与Linux无关，不感兴趣RocketMQ的可以直接跳过。</p>
<p>经过一段时间艰苦的统计，Writeback涉及的文件如下：</p>
<ul>
<li>50%的IO次数（20%左右的数据量） ConsumeQueue</li>
<li>10%的IO次数（60%左右的数据量）IndexFile</li>
<li>剩余：各种日志文件</li>
</ul>
<p>出现了这么多的ConsumeQueue及IndexFile，与我的印象出现了非常大的偏差。仔细阅读RocketMQ相关代码发现，所谓的刷盘逻辑竟然还有内置的机关！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConsumeQueue刷盘</span><br><span class="line">	1秒执行一次，遍历所有ConsumeQueue，但只在ConsumeQueue新增数据量超过一定大小（指定page数）才执行Flush</span><br><span class="line">	60秒（默认，可配置）的内置计时器，会触发所有ConsumeQueue一定Flush一次</span><br><span class="line">IndexFile刷盘</span><br><span class="line">	只对关闭的上一个IndexFile主动执行Flush</span><br></pre></td></tr></table></figure>
<p>果然不带着问题的阅读一定会错过很多细节，简单来说可以认为IndexFile完全没刷盘，依赖5秒一次的系统Writeback进行Flush，而ConsumeQueue随缘刷盘，流量较低的ConsumeQueue基本上会被系统Writeback调用刷盘。</p>
<h2><span id="6-为什么会有毛刺">6 为什么会有毛刺</span></h2><p>再回到之前拿到的所有IO请求的记录上，可以每次Writeback的系统IO请求量大而连续。</p>
<p>基本可以断定IO毛刺出现的原因是短时间（1秒内的某个ms级别的时间短）内磁盘负载因为请求队列数量过高而满载，同时也阻塞了应用进程的IO请求。</p>
<p>IO请求队列内的请求处理顺序由调度算法决定，各种算法的详细介绍可以自行搜索，这里仅简单介绍以满足阅读需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">noop</span><br><span class="line">	大致FIFO，做了一些优化可能导致饿死的情况</span><br><span class="line">cfq</span><br><span class="line">	每个线程&#x2F;进程一个队列，尽量确保公平</span><br><span class="line">deadline</span><br><span class="line">	读写队列分开，尽量避免饿死</span><br></pre></td></tr></table></figure>
<p>当前生效的IO调度算法在/sys/block/${device}/queue/scheduler这里可以查看或设置，这台机器目前使用的deadline算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#cat &#x2F;sys&#x2F;block&#x2F;sda&#x2F;queue&#x2F;scheduler</span><br><span class="line">noop [deadline] cfq</span><br></pre></td></tr></table></figure>
<p>deadline算法的核心参数包括write_expire(单位ms)，会尽量避免写操作的等待执行时间超过该参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#cat &#x2F;sys&#x2F;block&#x2F;sda&#x2F;queue&#x2F;iosched&#x2F;write_expire</span><br><span class="line">5000</span><br></pre></td></tr></table></figure>
<p>这里系统的毛刺峰值离5秒还有些距离，也意味着处理写请求基本按照FIFO原则，即Writeback的同一时间（极短时间内）产生的大量请求会阻塞其他进程的IO请求，导致毛刺。同时大量的IO请求本身也会导致较高的写延迟。</p>
<h2><span id="7-不均匀的writeback-迷之dirty_expire_centisecs">7 不均匀的Writeback-迷之dirty_expire_centisecs</span></h2><p>在之前，毛刺的产生已经定位，这里是另一个问题。在尝试拉长<strong>iostat</strong>与<strong>biosnoop</strong>监控结果的时间线进行分析后，又发现了一个问题：</p>
<ul>
<li>5秒一次的毛刺之外，存在着30秒一次的大毛刺</li>
<li>在30秒的大毛刺之际，Writeback产生的IO请求的数量是平时5秒毛刺时的10倍左右</li>
</ul>
<p>基本可以认定，这个较大的毛刺是因为更多的Writeback产生的IO请求而导致，那么为什么会出现这样不均匀的情况？</p>
<p>了解过Writeback机制的你一定知道<strong>dirty_expire_centisecs</strong>这个参数。对Dirty Page进行Writeback有两类条件，一类占用内存到一定比例，一类即是Page被标记为Dirty超过一定时间，这个一定时间即是<strong>dirty_expire_centisecs</strong>(单位ms)参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#cat &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_expire_centisecs</span><br><span class="line">3000</span><br></pre></td></tr></table></figure>
<p>查看该参数为3000，这意味着一个Page将在被标记Dirty的30s之后，被下一个周期的Writeback线程Flush到块设备。通常看来，如果系统流量平均，那么每时每刻，达到30s阈值的Dirty Page数量应该同样多，为什么会产生一个30秒周期的大毛刺，难道说系统流量（RocketMQ）每30秒有一波大流量（然而并没有）？</p>
<p>不禁怀疑自己掌握的<strong>dirty_expire_centisecs</strong>的概念是否正确，但查阅内核文档后与自己的印象完全吻合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;sysctl&#x2F;vm.txt</span><br><span class="line"></span><br><span class="line">dirty_expire_centisecs</span><br><span class="line"></span><br><span class="line">This tunable is used to define when dirty data is old enough to be eligible</span><br><span class="line">for writeout by the kernel flusher threads.  It is expressed in 100&#39;ths</span><br><span class="line">of a second.  Data which has been dirty in-memory for longer than this</span><br><span class="line">interval will be written out next time a flusher thread wakes up.</span><br></pre></td></tr></table></figure>
<p>再尝试搜索了一下<strong>dirty_expire_centisecs</strong>的实现，有收获：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;18353467&#x2F;implementation-of-dirty-expire-centisecs</span><br><span class="line"></span><br><span class="line">I asked this question on the linux-kernel mailing list and got an answer from Jan Kara. The timestamp that expiration is based on is the modtime of the inode of the file. Thus, multiple pages dirtied in the same file will all be written when the expiration time occurs because they&#39;re all associated with the same inode.</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;lkml.indiana.edu&#x2F;hypermail&#x2F;linux&#x2F;kernel&#x2F;1309.1&#x2F;01585.html</span><br></pre></td></tr></table></figure>
<p>在下面附上的邮件链接中也写到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Well, let me explain the mechanism in more detail: When the first page is</span><br><span class="line">dirtied in an inode, the current time is recorded in the inode. When this</span><br><span class="line">time gets older than dirty_expire_centisecs, all dirty pages in the inode</span><br><span class="line">are written. So with this mechanism in mind the behavior you describe looks</span><br><span class="line">expected to me.</span><br></pre></td></tr></table></figure>
<p>这是说，当一个inode下首次有dirty page时，时间即开始记录在inode上，达到超时时间后，inode所有的dirtypage（即是没到这个dirty page的超时时间）都会被一同writeback。</p>
<p>具体到RocketMQ的业务场景来说，由于密集的请求，在MQ启动之后，每一个检查周期所有的的ConsumeQueue文件都可能被修改过。那么很大概率，大部分ConsumeQueue在MQ启动的首个检查周期即被计时，直到<strong>dirty_expire_centisecs</strong>时间达到后，又一同被writeback，往复循环。所以会存在一个30s的大毛刺。</p>
<h2><span id="8-优化方案">8 优化方案</span></h2><p>目前想到三个思路：</p>
<ul>
<li>引入更频繁的Writeback避免5秒一次的毛刺</li>
<li>减少Writeback避免短时间大量IO请求的拥堵</li>
<li>尝试别的IO请求调度算法，使业务线程的IO请求不被阻塞出耗时毛刺</li>
</ul>
<p><strong>引入更频繁的Writeback避免5秒一次的毛刺</strong></p>
<p>这个操作的理论基础是将5秒一次的IO分散到更细粒度。但比较可惜在这里并不适合RocketMQ的业务场景，因为RocketMQ的流量过于巨大，每1秒产生的脏页所涉及到的文件，与每5秒统计一次并没有差别。</p>
<p>实测结果：将<strong>dirty_writeback_centisecs</strong>调整为1s后，每一秒都是毛刺。</p>
<p><strong>减少Writeback避免短时间大量IO请求的拥堵</strong></p>
<p>RocketMQ自身的所有数据文件基本都有定时flush的机制，可以不依赖系统Writeback。那么可以直接把周期性的Writeback的间隔拉长，或直接关闭周期性的Writeback。</p>
<p>实测结果：</p>
<ul>
<li><p>间隔拉长：将dirty_expire_centisecs参数调整为180秒后，5秒一次的毛刺完全消失，但180秒的毛刺仍然存在。</p>
</li>
<li><p>关闭周期性的writeback：理论上只影响日志的flush，不会引入断电后数据丢失的问题。但目前只有线上环境，还不敢测试。</p>
</li>
</ul>
<p><strong>尝试别的IO请求调度算法</strong></p>
<p>对其他的IO请求算法还需要更细致的调研才有进行测试的必要和把握，粗略看来cfq这种进程间相对更公平的算法，也许能够避免在Writeback出现大量IO时，应用进程仍能够合理分配到足够的份额。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/31/Initial_Process_in_SLF4j/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Terrell Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Initial_Process_in_SLF4j/" class="post-title-link" itemprop="url">日志初始化流程(1)-SLF4j</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-31 14:16:35" itemprop="dateCreated datePublished" datetime="2020-05-31T14:16:35+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-28 00:23:16" itemprop="dateModified" datetime="2020-12-28T00:23:16+08:00">2020-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->

<ul>
<li><a href="#1-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">1 背景知识</a></li>
<li><a href="#2-slf4j%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B">2 SLF4J加载流程</a><ul>
<li><a href="#21-slf4j%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">2.1 SLF4J使用方式</a></li>
<li><a href="#22-slf4j%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">2.2 SLF4J核心概念</a></li>
<li><a href="#23-slf4j%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93">2.3 SLF4J加载流程总结</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="1-背景知识">1 背景知识</span></h2><p>目前最流行的Java日志框架包括logback、log4j、log4j2，它们全都基于SLF4J这套API进行开发。SLF4J全称为Simple Logging Facade for Java，是为了给Java日志访问提供一个API框架。</p>
<p>绝大多数情况下，Java项目只需要在resources目录下准备好日志框架配置文件，并在代码中调用SLF4J相关的API即可实现日志功能。本文主要探究SLF4J及不同日志框架实现，在初始加载过程中的逻辑。</p>
<h2><span id="2-slf4j加载流程">2 SLF4J加载流程</span></h2><h3><span id="21-slf4j使用方式">2.1 SLF4J使用方式</span></h3><p>在使用过程中，用户往往只会接触到SLF4J的两个概念，一个是Logger，一个是LoggerFactory。大部分项目中通常可见如下方式进行日志初始化及输出的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(Test.class);</span><br><span class="line">logger.info(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Logger是一套API，是整个SLF4J-API体系下的一个主要用户入口，其约定了Logger需要提供按照不同日志级别将需要记录的对象进行记录的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(...)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(...)</span></span>;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoggerFactory是一个为不同日志框架实现来生产Logger的工具类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory = getILoggerFactory();</span><br><span class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="22-slf4j核心概念">2.2 SLF4J核心概念</span></h3><p><strong>ILoggerFactory</strong></p>
<p>在获取Logger的方法中又引入一个新的概念，ILoggerFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILoggerFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Logger <span class="title">getLogger</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>ILoggerFactory为日志框架需要实现的API，用来生产实际Logger实例。再回顾LoggerFactory.getLogger(String name)中的getILoggerFactory()方法的具体内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory <span class="title">getILoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有进行过初始化则进行初始化</span></span><br><span class="line">  <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LoggerFactory.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">        INITIALIZATION_STATE = ONGOING_INITIALIZATION;</span><br><span class="line">        <span class="comment">// 执行初始化</span></span><br><span class="line">        performInitialization();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (INITIALIZATION_STATE) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUCCESSFUL_INITIALIZATION:</span><br><span class="line">      <span class="comment">// 出现一个新东西，StaticLoggerBinder</span></span><br><span class="line">      <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unreachable code&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，如果没有进行初始化则进行初始化；如果执行成功执行过初始化，则通过StaticLoggerBinder返回ILoggerFactory实例。这里继续介绍初始化逻辑，将会涉及到StaticLoggerBinder的具体介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performInitialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  bind();</span><br><span class="line">  <span class="keyword">if</span> (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) &#123;</span><br><span class="line">    versionSanityCheck();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化的逻辑很简单，即调用bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isAndroid()) &#123;</span><br><span class="line">      <span class="comment">// 查找包里面所有的 org/slf4j/impl/StaticLoggerBinder.class</span></span><br><span class="line">      staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</span><br><span class="line">      <span class="comment">// 如果找到了多个说明引用了多个日志框架，这里会打日志</span></span><br><span class="line">      reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the next line does the binding</span></span><br><span class="line">    <span class="comment">// 这里才会触发StaticLoggerBinder的初始化</span></span><br><span class="line">    <span class="comment">// 如果之前找到了多个StaticLoggerBinder类，那这里可以认为是随缘加载哪个，不可控</span></span><br><span class="line">    StaticLoggerBinder.getSingleton();</span><br><span class="line">    INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class="line">    <span class="comment">// 这里打日志实际加载了哪个</span></span><br><span class="line">    reportActualBinding(staticLoggerBinderPathSet);</span><br><span class="line">    <span class="comment">// 附上Java doc解释吧：It used as a temporary substitute for the real ILoggerFactory during its auto-configuration which may re-enter LoggerFactory to obtain logger instances.</span></span><br><span class="line">    fixSubstituteLoggers();</span><br><span class="line">    <span class="comment">// 重放SubstituteLoggerFactory里面记录的event</span></span><br><span class="line">    replayEvents();</span><br><span class="line">    <span class="comment">// release all resources in SUBST_FACTORY</span></span><br><span class="line">    SUBST_FACTORY.clear();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class="line">   ......</span><br><span class="line">  &#125; <span class="keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行到这段代码之前，StaticLoggerBinder其实是没有加载的。这里通过调用StaticLoggerBinder.getSingleton()的单例方法，来实现具体日志框架的初始化。</p>
<p><strong>StaticLoggerBinder</strong></p>
<p>org.slf4j.impl.StaticLoggerBinder等效于SPI，下面是SLF4J中的默认实现（不会打包）。每个日志框架中必须按照这个全限定类名实现自己的StaticLoggerBinder类，并包括以下方法和属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLoggerBinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticLoggerBinder SINGLETON = <span class="keyword">new</span> StaticLoggerBinder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticLoggerBinder <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String REQUESTED_API_VERSION = <span class="string">&quot;1.6.99&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticLoggerBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;This code should have never made it into slf4j-api.jar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoggerFactory <span class="title">getLoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;This code should never make it into slf4j-api.jar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoggerFactoryClassStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;This code should never make it into slf4j-api.jar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，具体的ILoggerFactory也由具体的StaticLoggerBinder进行返回，每个日志框架自己的初始化逻辑均由自己实现的StaticLoggerBinder发起。</p>
<h3><span id="23-slf4j加载流程总结">2.3 SLF4J加载流程总结</span></h3><p>现在对上文涉及到的流程进行一个汇总</p>
<p><strong>获取Logger流程</strong></p>
<pre class="mermaid">sequenceDiagram
    participant User
    participant LoggerFactory
    participant ILoggerFactory
    User ->>+ LoggerFactory: getLogger(name)
    LoggerFactory ->> LoggerFactory: getILoggerFactory()
    LoggerFactory ->>+ ILoggerFactory: getLogger(name)
    ILoggerFactory ->>- LoggerFactory: Logger
    LoggerFactory ->>- User: Logger</pre>

<p><strong>首次加载流程</strong></p>
<pre class="mermaid">sequenceDiagram
    participant getILoggerFactory()
    participant performInitialization()
    participant bind()
    participant StaticLoggerBinder
    getILoggerFactory() ->>+ performInitialization(): 
    performInitialization() ->>+ bind(): 
    bind() ->>+ StaticLoggerBinder: getSingleton()
    Note right of StaticLoggerBinder: 加载类<br>执行静态代码块<br>执行getSingleton()
    StaticLoggerBinder ->>- bind(): StaticLoggerBinder
    bind() ->>- performInitialization(): 
    performInitialization() ->>- getILoggerFactory(): ;</pre>

<p>到StaticLoggerBinder.init()的部分，就是各个日志框架自己的初始化的逻辑。下面将一一介绍三个主流日志框架的初始化流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/23/RocketMQ_Framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Terrell Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/23/RocketMQ_Framework/" class="post-title-link" itemprop="url">RocketMQ-架构篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-23 21:10:35" itemprop="dateCreated datePublished" datetime="2020-05-23T21:10:35+08:00">2020-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-23 00:20:24" itemprop="dateModified" datetime="2020-12-23T00:20:24+08:00">2020-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="rocketmq-架构篇">RocketMQ-架构篇</span></h1><!-- toc -->

<ul>
<li><a href="#1-broker">1、Broker</a><ul>
<li><a href="#11-%E4%BB%8E%E5%90%AF%E5%8A%A8%E6%84%9F%E7%9F%A5%E6%9E%B6%E6%9E%84">1.1、从启动感知架构</a><ul>
<li><a href="#111-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">1.1.1、核心组件</a></li>
<li><a href="#112-%E5%AD%98%E5%82%A8%E7%BB%84%E4%BB%B6">1.1.2、存储组件</a></li>
<li><a href="#113-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6">1.1.3、网络组件</a></li>
</ul>
</li>
<li><a href="#12-%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92">1.2、消息投递</a><ul>
<li><a href="#121-%E5%A4%84%E7%90%86%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">1.2.1、处理发送请求</a></li>
<li><a href="#122-flush%E4%B8%8Eha">1.2.2、Flush与HA</a></li>
<li><a href="#123-%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95">1.2.3、建立索引</a></li>
<li><a href="#124-commitlog-consumequeue-index">1.2.4、CommitLog ConsumeQueue Index</a></li>
</ul>
</li>
<li><a href="#13-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9">1.3、消息消费</a></li>
</ul>
</li>
<li><a href="#2-nameserver">2、NameServer</a><ul>
<li><a href="#21-%E7%BB%93%E6%9E%84">2.1、结构</a></li>
<li><a href="#22-%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%9B%B4%E6%96%B0">2.2、注册与更新</a></li>
<li><a href="#23-%E8%B7%AF%E7%94%B1">2.3、路由</a></li>
</ul>
</li>
<li><a href="#3-client">3、Client</a><ul>
<li><a href="#31-%E7%BB%93%E6%9E%84">3.1、结构</a></li>
<li><a href="#32-%E5%8F%91%E9%80%81">3.2、发送</a><ul>
<li><a href="#311-%E9%80%9A%E7%94%A8%E6%B5%81%E7%A8%8B">3.1.1、通用流程</a></li>
<li><a href="#312-%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF">3.1.2、批量消息</a></li>
<li><a href="#313-%E6%8C%87%E5%AE%9A%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF">3.1.3、指定队列消息</a></li>
</ul>
</li>
<li><a href="#32-%E6%B6%88%E8%B4%B9">3.2、消费</a><ul>
<li><a href="#321-pull%E6%A8%A1%E5%BC%8F">3.2.1、Pull模式</a></li>
<li><a href="#322-push%E6%A8%A1%E5%BC%8F">3.2.2、Push模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-filterserver">4、FilterServer</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-broker">1、Broker</span></h2><p>Broker是RocketMQ的服务端组件之一，所有消息存储在Broker上，所有的投递、消费请求也都由Broker进行处理。Broker是有状态的应用，本地存储了消息、索引、消费位点等信息，不同的Broker具有不同的角色。</p>
<p>下面简单介绍Broker的主要结构及功能</p>
<h3><span id="11-从启动感知架构">1.1、从启动感知架构</span></h3><h4><span id="111-核心组件">1.1.1、核心组件</span></h4><p>BrokerStartup#main为broker启动入口</p>
<pre class="mermaid">sequenceDiagram
    participant BrokerStartup
    participant BrokerController
    participant MessageStore
    participant RemotingServer
    BrokerStartup->>BrokerStartup: createBrokerController(String[] args)
    BrokerStartup->>BrokerController: initialize()
    Note left of BrokerController: new DefaultMessageStore(Config)<br>new NettyRemotingServer(config)<br>......
    BrokerController->>BrokerStartup: boolean: success
    BrokerStartup->>BrokerStartup: start(BrokerController)
    BrokerStartup->>BrokerController: start()
    BrokerController->>MessageStore: start()
    BrokerController->>RemotingServer: start()
    BrokerController->>BrokerController: registerBrokerAll()</pre>
<ul>
<li>BrokerController为broker控制器，管理broker所有顶层对象的生命周期</li>
<li>MessageStore为存储服务，默认实现为DefaultMessageStore</li>
<li>RemotingServer为网络服务，默认实现为NettyRemotingServer</li>
<li>createBrokerController(String[])中，我们根据配置初始化四个核心配置文件，并使用配置文件创建BrokerController对象<ul>
<li>BrokerConfig: broker基础配置，主要包括集群属性、文件路径、功能开关、性能参数等</li>
<li>NettyServerConfig：broker服务端配置，服务端主要用于接收请求</li>
<li>NettyClientConfig：broker客户端配置，主要用于发送请求（to nameServer/client）</li>
<li>MessageStoreConfig：存储服务参数配置</li>
</ul>
</li>
<li>BrokerController同时还控制其他顶层对象初始化，这里不一一介绍</li>
</ul>
<h4><span id="112-存储组件">1.1.2、存储组件</span></h4><p>存储基于本地文件存储</p>
<pre class="mermaid">graph TD
    MessageStore --> ReputMessageService;
    MessageStore --> HAService;
    MessageStore --> CommitLog;
    CommitLog --> FlushCommitLogService;
    CommitLog --> MappedFileQueue;</pre>

<ul>
<li>CommitLog：数据文件对象，主要的属性包括：<ul>
<li>FlushCommitLogService：刷盘服务，主要为定时模式</li>
<li>MappedFileQueue：具体的文件列表，文件为MMap对象，直接对接操作系统</li>
<li>MMap文件：单个文件固定1G大小，所有消息不区分主题等属性，在文件中连续存放</li>
</ul>
</li>
<li>ReputMessageService：消费CommitLog，将消息按topic等纬度，生成不同的索引文件，便于消费</li>
<li>HAService：主从同步服务</li>
</ul>
<h4><span id="113-网络组件">1.1.3、网络组件</span></h4><p>网络基于Netty实现</p>
<pre class="mermaid">sequenceDiagram
    participant BrokerStartup
    participant BrokerController
    participant RemotingServer
    BrokerStartup ->> BrokerController: initialize()
    BrokerController ->> BrokerController: registerProcessor()
    loop 注册处理器
        BrokerController ->> RemotingServer: registerProcessor()
    end
    BrokerController ->> BrokerStartup: boolean: success</pre>

<p>启动时，在BrokerController在创建RemotingServer之后，会将所有Processor注册</p>
<pre class="mermaid">classDiagram
    class RemotingServer{
        <<interface>>
        registerProcessor()
        start()
        shutdown()
    }
    class NettyRemotingAbstract{
        <<abstract>>
    }
    class NettyRemotingServer{
    }
    class NettyRequestProcessor{
        <<interface>>
        processRequest()
        rejectRequest()
    }
    class SendMessageProcessor
    class PullMessageProcessor
    RemotingServer <|.. nettyremotingserver: realization nettyremotingabstract <|-- inheritance nettyrequestprocessor <|.. sendmessageprocessor: pullmessageprocessor: realization< pre>

<p>主要的Processor包括：</p>
<ul>
<li>SendMessageProcessor：处理投递时发送、重试消息等请求</li>
<li>PullMessageProcessor：处理消费时拉取消息等请求</li>
</ul>
<h3><span id="12-消息投递">1.2、消息投递</span></h3><h4><span id="121-处理发送请求">1.2.1、处理发送请求</span></h4><p>以下述场景为例：</p>
<ul>
<li>Broker角色：master</li>
<li>消息类型：普通消息</li>
<li>消息数量：单条</li>
<li>Broker配置：ASYNC_FLUSH ASYNC_MASTER</li>
</ul>
<pre class="mermaid">sequenceDiagram
    participant NettyRemotingAbstract
    participant SendMessageProcessor
    participant DefaultMessageStore
    participant CommitLog
    participant MappedFile
    participant MappedByteBuffer
    NettyRemotingAbstract ->>+ SendMessageProcessor: processRequest()
    SendMessageProcessor ->>+ DefaultMessageStore: putMessage()
    DefaultMessageStore ->>+ CommitLog: putMessage()
    CommitLog ->>+ MappedFile: appendMessage()
    MappedFile ->> MappedByteBuffer: put()
    MappedByteBuffer ->> MappedFile: 
    MappedFile ->>- CommitLog: AppendMessageResult
    CommitLog ->>- DefaultMessageStore: PutMessageResult
    DefaultMessageStore ->>- SendMessageProcessor: PutMessageResult
    SendMessageProcessor ->>- NettyRemotingAbstract: processRequest()</pre>

<ul>
<li>RemotingServer收到请求后，根据RemoteCommand，将请求分发给对应的Processor，这里由SendMessageProcessor处理投递消息的请求</li>
<li>SendMessageProcessor对Broker状态及消息进行必要的验证后，将请求重新包装为MessageExtBrokerInner，交给DefaultMessageStore继续处理</li>
<li>DefaultMessageStore同样对Broker状态及消息进行部分信息的验证后，交给CommitLog处理</li>
<li>CommitLog获取到目前最新的MappedFile，交给MappedFile进行写入</li>
<li>MappedFile将消息格式化、序列化后，写入MappedFile具体文件对应的MappedByteBuffer中</li>
</ul>
<p>至此，一次发送请求处理完毕，消息生产者将会收到答复，然而Broker端的处理工作并没有结束</p>
<h4><span id="122-flush与ha">1.2.2、Flush与HA</span></h4><p>CommitLog的putMessage()方法中，当操作MappedFile写入完毕之后，会调用handleDiskFlush()、handleHA()。在上述的异步配置Broker中，这两个方法并不会导致阻塞，请求得以直接返回。</p>
<p>在异步刷盘的情况下，Flush服务的实现类为FlushRealTimeService，通常会在每500ms触发一次强制flush</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlushRealTimeService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          ......</span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">              ......</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// false</span></span><br><span class="line">                    <span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">                        Thread.sleep(interval);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// default 500ms</span></span><br><span class="line">                        <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">                    &#125;</span><br><span class="line">                    CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在异步主备的情况下，slave与master建立HA链接，定期心跳自身位点，请求数据</p>
<h4><span id="123-建立索引">1.2.3、建立索引</span></h4><p>在处理消息投递的流程中，收到的所有消息顺序存储在连续文件中，若需消费，则需要建立对应的索引。Broker在消息写入CommitLog后，会有ReputMessageService对写入commitLog的消息进行重新消费，以根据topic+queueId，构建索引文件(ConsumerQueue)</p>
<pre class="mermaid">sequenceDiagram
    participant ReputMessageService
    participant DefaultMessageStore

    loop doReput()
        ReputMessageService ->>+ DefaultMessageStore: doDispatch()
        Note right of DefaultMessageStore: dispathers to:<br>build consume queue<br>build index
    DefaultMessageStore ->>- ReputMessageService: 
    end</pre>

<p>ReputMessageService是DefaultMessaeStore的一个内部类，定时执行doReput()方法，将最近的消息交给DefaultMessageStore中记录的dispatcher执行，包括：</p>
<ul>
<li>CommitLogDispatcherBuildConsumeeQueue：构建consume queue文件</li>
<li>CommitLogDispatcherBuildIndex：构建index文件</li>
</ul>
<h4><span id="124-commitlog-consumequeue-index">1.2.4、CommitLog ConsumeQueue Index</span></h4><p>从前面的的流程中可以得知，Broker端接收一条投递的消息至少产生了三个文件，他们分别的含义及用途为：</p>
<ul>
<li>CommitLog：存储消息体本身</li>
<li>ConsumeQueue：根据Topic-Queue，构建消息在CommitLog中的索引</li>
<li>Index：根据消息在CommitLog中的位点，构建消息在CommitLog中的索引</li>
</ul>
<h3><span id="13-消息消费">1.3、消息消费</span></h3><p>这里主要介绍Broker端在处理消费请求时的逻辑。</p>
<p>对于Broker端，所有消息消费的请求都是相同的，下面是拉取消息请求头的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullMessageRequestHeader</span> <span class="keyword">implements</span> <span class="title">CommandCustomHeader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> Integer queueId;</span><br><span class="line">    <span class="keyword">private</span> Long queueOffset;</span><br><span class="line">    <span class="keyword">private</span> Integer maxMsgNums;</span><br><span class="line">    <span class="comment">// 标记，主要与事务消息相关</span></span><br><span class="line">    <span class="keyword">private</span> Integer sysFlag;</span><br><span class="line">    <span class="keyword">private</span> Long commitOffset;</span><br><span class="line">    <span class="comment">// 轮询时间</span></span><br><span class="line">    <span class="keyword">private</span> Long suspendTimeoutMillis;</span><br><span class="line">  	<span class="comment">// 过滤条件</span></span><br><span class="line">    <span class="keyword">private</span> String subscription;</span><br><span class="line">  	<span class="comment">// 订阅信息版本</span></span><br><span class="line">    <span class="keyword">private</span> Long subVersion;</span><br><span class="line">  	<span class="comment">// subscription类型</span></span><br><span class="line">    <span class="keyword">private</span> String expressionType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>较为常见的集群模式的消费请求处理的过程如下：</p>
<ul>
<li>检查信息<ul>
<li>Broker状态：是否可读</li>
<li>订阅组组信息：是否存在、是否启用</li>
<li>主题信息：是否存在、是否可读、请求的队列是否存在</li>
<li>消费组信息：消费组是否存在、消费组下的订阅组是否存在、订阅组的版本是否最新</li>
<li>其他非核心路径的检查……</li>
</ul>
</li>
<li>查询消息<ul>
<li>根据queueOffset从ConsumeQueue中查询到对应CommitLog的位点及大小</li>
<li>根据CommitLog的位点及大小从CommitLog中查询到对应数据</li>
</ul>
</li>
<li>更新统计数据</li>
<li>返回</li>
</ul>
<h2><span id="2-nameserver">2、NameServer</span></h2><p>NameServer是RocketMQ的服务端组件之一，为MQ集群提供协调功能，记录并监控所有Broker、Topic信息。NameServer是无状态的应用。</p>
<h3><span id="21-结构">2.1、结构</span></h3><p>NameServer结构和Broker类似，同样是Startup-&gt;Controller的启动结构，几个核心组件如下：</p>
<ul>
<li>NameSrvController<ul>
<li>RouteInfoManager：namesrv上所有数据的管理，包括topic、broker等</li>
<li>BrokerHousekeepingService：broker下线（或异常）时的处理</li>
</ul>
</li>
</ul>
<p>上述功能基本比较简单，不涉及持久化、同步等概念，仅有一个DefaultRequestProcessor负责具体请求的处理。下面简单介绍其主要功能</p>
<h3><span id="22-注册与更新">2.2、注册与更新</span></h3><p>在Broker与NameServer间会维持一个长链接，Broker定期向NameServer进行注册（心跳），注册的信息包括</p>
<ul>
<li>Broker集群信息：ClusterName、BrokerName、BrokerId</li>
<li>BrokerIp</li>
<li>Topic信息</li>
</ul>
<p>这些信息的心跳会使得NameServer上的RouteInfoManager随之更新。RouteInfoManager的主要属性包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line">HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line">HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line">HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br></pre></td></tr></table></figure>
<p>每隔10s，NameServer会检查BrokerLiveTable。如果存在超过120s没有收到更新，会认为Broker已失效，将其信息移除。长链接断开也会触发该逻辑。</p>
<h3><span id="23-路由">2.3、路由</span></h3><p>RocketMQ的路由更新为非实时，客户端会定期从NameServer更新需要的路由信息。</p>
<h2><span id="3-client">3、Client</span></h2><p>Client时RocketMQ的客户端，负责消息的生产、消费。下面简单介绍客户端主要的发送及消费逻辑</p>
<h3><span id="31-结构">3.1、结构</span></h3><pre class="mermaid">classDiagram
    class MQProducer{
        <<interface>>
        SendResult send(Message msg)
        SendResult send(Message msg, MessageQueue mq)
        SendResult send(Collection<message> msgs)
        SendResult send(Collection<message> msgs, MessageQueue mq)
        ...
    }
    class DefaultMQProducer{
    }
    class DefaultMQProducerImpl{
    }
    class MQPullConsumer{
        <<interface>>
        pull(MessageQueue mq, long offset, int maxNumx, ...)
        updateConsumeOffset(MessageQueue mq, long offset)
        fetchConsumeOffset(MessageQueue mq, ...)
        sendMessageBack(MessageExt msg, String brokerName, ...)
        ...
    }
    class DefaultMQPullConsumer{

    }
    class DefaultMQPullConsumerImpl{

    }
  class    PullAPIWrapper{
      pullKernelImpl(MessageQueue mq, long offset, ...)
  }
    class MQPushConsumer{
        <<interface>>
        registerListener(MessageListener msgListener)
        subscribe(String topic,...)
        unsubscribe(String topic)
        ...
    }
    class DefaultMQPushConsumer{

    }
    class DefaultMQPushConsumerImpl{
        pullMessage(PullRequest pullRequest)
        ...
    }
    class MQClientInstance{
        findBrokerAddrByTopic(String topic)
        getTopicRouteTable()
        getMQClientAPIImpl()
        ...
    }
    class MQClientAPIImpl{
        sendMessage(String addr, Message msg...)
        sendMessageSync(...)
        sendMessageAsync(...)
        pullMessage(String addr, PullMessageRequestHeader requestHeader, ...)
        pullMessageAsync(String addr, RemotingCommand request, ...)
        pullMessageSync(String addr, RemotingCommand request, ...)
        ...
    }
    class RemotingClient{
        <<interface>>
        invokeSync(String addr, RemotingCommand request...)
        invokeAsync(...)
        ...
    }
    MQProducer <|.. defaultmqproducer: realization defaultmqproducer <-- defaultmqproducerimpl: association defaultmqproducerimpl mqclientinstance: mqpullconsumer <|.. defaultmqpullconsumer: defaultmqpullconsumer defaultmqpullconsumerimpl: defaultmqpullconsumerimpl pullapiwrapper: mqpushconsumer defaultmqpushconsumer: defaultmqpushconsumer defaultmqpushconsumerimpl: defaultmqpushconsumerimpl pullapiwrapper mqclientinstance mqclientapiimpl: mqclientapiimpl remotingclient: association< pre>

<p>如图，默认情况下，客户端中所有Producer、Consumer共用一个MQClientInstance，可以通过设置instanceName来确保使用不同的MQClientInstance实例。</p>
<p>Producer只有一种实现，可以实现发送单条、批量消息，可以指定队列发送。</p>
<p>Consumer有两种实现，pull及push模式，但内在均通过PullAPIWrapper拉取消息，push模式为pull模式的一种封装。</p>
<h3><span id="32-发送">3.2、发送</span></h3><p>下面简单介绍发送消息的流程</p>
<h4><span id="311-通用流程">3.1.1、通用流程</span></h4><p>以发送单条消息、不指定队列为例</p>
<pre class="mermaid">sequenceDiagram
    participant DefaultMQProducerImpl
    participant MQClientInstance
    participant MQClientAPIImpl
    participant RemotingClient
    DefaultMQProducerImpl ->> DefaultMQProducerImpl: send(Message msg)
    DefaultMQProducerImpl ->> DefaultMQProducerImpl: sendKernelImpl(Message msg)
    DefaultMQProducerImpl ->>+ MQClientInstance: getMQClientAPIImpl()
    MQClientInstance ->>- DefaultMQProducerImpl: MQClientAPIImpl
    DefaultMQProducerImpl ->>+ MQClientAPIImpl: sendMessage()
    MQClientAPIImpl ->>+ RemotingClient: invokeSync()
    RemotingClient ->>- MQClientAPIImpl: SendResult
    MQClientAPIImpl ->>- DefaultMQProducerImpl: SendResult</pre>

<p>DefaultMQProducerImpl主要负责业务层面的处理。在最初调用DefaultMQProducerImpl时，我们只需要提供参数msg，DefaultMQProducerImpl中会查询topic的路由，会按照轮询机制返回本次投递的目标队列（MessageQueue）。之后DefaultMQProducerImpl会根据队列查询队列所在Broker的ip，同时将本次投递的内容中的信息整合生成RequestHeader。上述信息作为参数由DefaultMQProducerImpl调用MQClientAPIImpl的sendMessage()方法时一并传递。</p>
<p>MQClientAPIImpl主要负责对接网络层与业务层，有它调用netty客户端发送请求。</p>
<h4><span id="312-批量消息">3.1.2、批量消息</span></h4><p>批量消息的发送接口相对上面介绍的单条消息，仅仅将入参由<code>Msssage</code>替换为了<code>Collection&lt;Message&gt;</code>。在发送过程中，<code>Collection&lt;Message&gt;</code>被封装为<code>Message</code>，其余流程没有变化。</p>
<h4><span id="313-指定队列消息">3.1.3、指定队列消息</span></h4><p>指定队列消息的发送接口在参数中增加了<code>MessageQueue</code>，这使得DefaultMQProducerImpl不再需要选择队列投递，其余逻辑基本一致。</p>
<p>值得注意的是，未指定队列的消息在失败后将自动更换队列重试三次，而指定队列消息在失败后并不会重试，所有异常将有发送的调用方进行处理。</p>
<h3><span id="32-消费">3.2、消费</span></h3><p>在前面的结构分析中可以看到，消费相关的类有两种，分别是pull和push模式，下面分别介绍两种模式的特点</p>
<h4><span id="321-pull模式">3.2.1、Pull模式</span></h4><p>回到上面MQPullConsumer的接口列表中，可以看到pull模式的消费非常比较直接：提供MessageQueue及offset，直接尝试获取对应位点的消息。</p>
<p>首先需要介绍典型的Topic的消费模型：</p>
<pre class="mermaid">graph TB
        Topic --- MessageQueue-1
    Topic --- MessageQueue-2
    Topic --- MessageQueue-3
    Topic --- MessageQueue-4
    Topic --- MessageQueue-5
    Topic --- MessageQueue-6
    subgraph  
    MessageQueue-5 --> Group-A-Client-3
    end
    subgraph  
    MessageQueue-6 --> Group-A-Client-4
    end
    subgraph  
    MessageQueue-3 --> Group-A-Client-2
    MessageQueue-4 --> Group-A-Client-2
    end
    subgraph  
    MessageQueue-1-->Group-A-Client-1
    MessageQueue-2-->Group-A-Client-1
    end</pre>

<ul>
<li>一个topic可能有多个MessageQueue</li>
<li>一个MessageQueue通常只被一个客户端消费</li>
<li>一个客户端通常可以消费多个MessageQueue</li>
</ul>
<p>可以看出，pull模式消费这里涉及到两个需要考虑的问题：</p>
<ul>
<li>分布式多客户端条件下，如何协调客户端与MessageQueue的对应关系</li>
<li>位点管理：存储在本地、或是服务端（Broker），这里同样涉及客户端到MessageQueue的协调问题</li>
</ul>
<p>在pull模式下，这些问题都需要调用方自己去解决。同时RocketMQ也提供了push的消费模式作为补充，可以算是对pull模式在可用性上的一个优化。</p>
<h4><span id="322-push模式">3.2.2、Push模式</span></h4><p>Push模式可以简单的理解为一个订阅-发布模式：Client向Broker订阅Topic下的消息，调用方在Client中注册一个Listerner，在消息到达时调用Listener进行处理。在这种情境下，Broker知道一共有哪些Client。顺理成章地，Client在RocketMQ的体系下能够感知当前一共有多少Client，再结合Topic所拥有的MessageQueue数量，按照同一的逻辑，这里就可以对Client-MessageQueue进行分配（负载均衡），这即是push模式对pull模式下第一个问题提供的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">负载均衡有五种默认策略提供，分别是：</span><br><span class="line">AllocateMessageQueueAveragely：平均分配</span><br><span class="line">AllocateMessageQueueAveragelyByCircle：平均轮询分配</span><br><span class="line">AllocateMessageQueueConsistentHash：一致性哈希</span><br><span class="line">AllocateMessageQueueByConfig：自定义配置</span><br><span class="line">AllocateMessageQueueByMachineRoom：根据机房</span><br></pre></td></tr></table></figure>
<p>接下来是位点管理。Push模式还分为两种：集群模式与广播模式。这为pull模式的第二个问题提供了解决方案</p>
<ul>
<li>集群模式：所有消息只被最多一个客户端消费。位点以消费组为纬度，在broker上存储</li>
<li>广播模式：所有消息被每个客户端消费。位点以消费组为纬度，在本地存储</li>
</ul>
<p>同时还需要注意，前面有提到push模式为pull模式的一种封装，内在仍为pull的模式。这意味着并不是Broker每到一条新消息就会推送给Client，而是Client通过轮询的方式不停从Broker进行查询。在消费速度大于生产速度，不存在堆积的时候，消息近似于到达Broker即被Client端拿走；而当消费速度小于生产速度时，本地会有缓存队列缓存即将消费的一段消息，提升消费速度。</p>
<h2><span id="4-filterserver">4、FilterServer</span></h2><p>FilterServer是RocketMQ的服务端组件之一，主要用于消息过滤，目前还没有一定需要使用的场景。</p>
<p>通常我们有更简单的使用tag的方式来完成消费消息的过滤，FilterServer则是通过运行上传的代码对消息进行过滤。</p>
</|..></interface></interface></interface></message></message></interface></pre></|..></interface></abstract></interface></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/23/RocketMQ_Features/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Terrell Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/23/RocketMQ_Features/" class="post-title-link" itemprop="url">RocketMQ-特性篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-23 16:45:00" itemprop="dateCreated datePublished" datetime="2020-05-23T16:45:00+08:00">2020-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-27 23:36:13" itemprop="dateModified" datetime="2020-12-27T23:36:13+08:00">2020-12-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- tag -->

<h2><span id="1-有序性">1、有序性</span></h2><p>在某些特定业务场景，可能对消息的顺序有要求。如数据库binlog同步要求binlog内容一定是有序的，如订单管理中对同一个订单的操作要求也是有序的，否则可能得到预期外的结果。</p>
<p>Topic的队列是我们实现有序性的关键，一个topic中，任意队列内部的所有消息均可以认为是有序的，均满足先进先出的有序条件。</p>
<p>针对有序性的需求，围绕队列展开，通常有两种解决方案。</p>
<h3><span id="11-全局有序">1.1、全局有序</span></h3><p>全局有序是指，业务对有序性对要求是一个topic内所有消息全部有序。为了达到全局有序的要求，可以将topic的队列数设置为1，即是说所有消息，均投递至同一个队列中，自然也就达到全局有序的效果。</p>
<h3><span id="12-分组有序">1.2、分组有序</span></h3><p>分组有序是指，业务对一个topic内的所有消息按照某种条件水平拆分为不同的分组后，组内有序。已知topic的单个队列天然有序，那么只需要将水平拆分后的一组消息，全部发送至同一个topic的队列，即可实现分组有序。</p>
<table>
<thead>
<tr>
<th>有序级别</th>
<th>实现方式</th>
<th>适合场景</th>
</tr>
</thead>
<tbody><tr>
<td>全局有序</td>
<td>topic队列数设置为1，消费者顺序消费</td>
<td>binlog同步</td>
</tr>
<tr>
<td>分组有序</td>
<td>消息按照分组规则固定投递至topic内的某一个队列，消费者顺序消费</td>
<td>订单、商品等按主键id拆分</td>
</tr>
</tbody></table>
<h4><span id="121-分组有序的投递方式">1.2.1、分组有序的投递方式</span></h4><p>分组有序的投递方式要求我们，数据根据一定条件投递到指定队列，RocketMQ也提供了指定队列的投递接口，可以分为两类：直接指定MessageQueue，或提供MessageQueue生成算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQProducer</span> <span class="keyword">extends</span> <span class="title">ClientConfig</span> <span class="keyword">implements</span> <span class="title">MQProducer</span> </span>&#123;</span><br><span class="line">  send(org.apache.rocketmq.common.message.Message, org.apache.rocketmq.common.message.MessageQueue)</span><br><span class="line">  ......</span><br><span class="line">  send(org.apache.rocketmq.common.message.Message, org.apache.rocketmq.client.producer.MessageQueueSelector, java.lang.Object)</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MessageQueue</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6191200464116433425L</span>;</span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> String brokerName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageQueueSelector</span> </span>&#123;</span><br><span class="line">    <span class="function">MessageQueue <span class="title">select</span><span class="params">(<span class="keyword">final</span> List&lt;MessageQueue&gt; mqs, <span class="keyword">final</span> Message msg, <span class="keyword">final</span> Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="122-分组有序的队列获取">1.2.2、分组有序的队列获取</span></h4><p>在分组有序的投递场景下，业务方会希望MessageQueue是不变的，在MessageQueue不变动的情况下才能确保业务按照条件散列后获得的MessageQueue不变。而Broker的停机升级、故障切换等场景又是不可避免的，实际MessageQueue的变化总在发生。</p>
<p>针对这类情况，RocketMQ在nameserver中提供了一个配置方式，可以将topic的队列数写在nameserver的kv存储中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.tools.command.topic.UpdateOrderConfCommand</span><br></pre></td></tr></table></figure>
<p>当nameserver存在topic相关的orderConf时，client从nameserver查询到的MessageQueue就不再是nameserver上broker注册的实时信息，而是从orderConf中直接拼装而成，是一个不变的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopicPublishInfo <span class="title">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> </span>&#123;</span><br><span class="line">  TopicPublishInfo info = <span class="keyword">new</span> TopicPublishInfo();</span><br><span class="line">  info.setTopicRouteData(route);</span><br><span class="line">  <span class="comment">// 从orderConf中拼装</span></span><br><span class="line">  <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="keyword">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    String[] brokers = route.getOrderTopicConf().split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String broker : brokers) &#123;</span><br><span class="line">      String[] item = broker.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">      <span class="keyword">int</span> nums = Integer.parseInt(item[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">        MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, item[<span class="number">0</span>], i);</span><br><span class="line">        info.getMessageQueueList().add(mq);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info.setOrderTopic(<span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 从broker注册信息中获取</span></span><br><span class="line">    ......</span><br><span class="line">    info.setOrderTopic(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2-消费失败的处理">2、消费失败的处理</span></h2><p>当消息消费失败时，RocketMQ提供了一些封装机制来降低重试使用成本并提高效率</p>
<h3><span id="21-失败后重试">2.1、失败后重试</span></h3><p>RocketMQ的消费模式有两种：顺序消费、并发消费。无论是顺序消费、并发消费，都支持单条或多条。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListenerOrderly</span> <span class="keyword">extends</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function">ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ConsumeOrderlyContext context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListenerConcurrently</span> <span class="keyword">extends</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function">ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在顺序消费的情况下，消费失败后本轮消费的所有消息将会全部重试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ConsumeOrderlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ConsumeOrderlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">      <span class="keyword">case</span> SUCCESS:</span><br><span class="line">        ......</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">        ......</span><br><span class="line">          <span class="comment">// 检查重试次数</span></span><br><span class="line">          <span class="keyword">if</span> (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">            <span class="comment">// consume later</span></span><br><span class="line">            ......</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// commit</span></span><br><span class="line">            .....</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkReconsumeTimes</span><span class="params">(List&lt;MessageExt&gt; msgs)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.getReconsumeTimes() &gt;= getMaxReconsumeTimes()) &#123;</span><br><span class="line">        MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));</span><br><span class="line">        <span class="comment">// 如果超过重试次数，消息发回broker</span></span><br><span class="line">        <span class="keyword">if</span> (!sendMessageBack(msg)) &#123;</span><br><span class="line">          <span class="comment">// 发送失败则继续重试（重发）</span></span><br><span class="line">          suspend = <span class="keyword">true</span>;</span><br><span class="line">          msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有超过重试次数则继续本地重试</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        suspend = <span class="keyword">true</span>;</span><br><span class="line">        msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> suspend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当重试超过最大次数，则发回broker。</p>
<p>在并发消费的情况下，消费失败后分为两种情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ConsumeConcurrentlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ConsumeConcurrentlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">            <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">            <span class="comment">// 广播模式，消费失败忽略</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                    MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                    log.warn(<span class="string">&quot;BROADCASTING, the message consume failed, drop it, &#123;&#125;&quot;</span>, msg.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">            <span class="comment">// 集群模式</span></span><br><span class="line">                List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                    MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                  <span class="comment">// 消费失败直接发回broker</span></span><br><span class="line">                    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                        msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                        msgBackFailed.add(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                    consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 发送失败的部分本地再尝试重试</span></span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>广播模式下消费失败的消息将会直接全部忽略，集群模式下失败消息会直接发往broker重试</p>
<h3><span id="22-broker端处理发回的失败消息">2.2、Broker端处理发回的失败消息</span></h3><p>Broker端依旧是SendMessageProcessor处理Consumer发回的消息，但与处理正常投递不同，走到另外一条逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.broker.processor.SendMessageProcessor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">          <span class="comment">// consumer发回的失败消息</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.consumerSendMsgBack(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// 正常投递</span></span><br><span class="line">          ......</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.broker.processor.SendMessageProcessor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">consumerSendMsgBack</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand request)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 获取订阅信息</span></span><br><span class="line">  SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">    <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</span><br><span class="line">  ......</span><br><span class="line">    <span class="comment">// 检查broker全县</span></span><br><span class="line">  <span class="keyword">if</span> (!PermName.isWriteable(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line">    response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">    response.setRemark(<span class="string">&quot;the broker[&quot;</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class="string">&quot;] sending message is forbidden&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 订阅信息中查询并检查重试队列相关的信息</span></span><br><span class="line">  <span class="keyword">if</span> (subscriptionGroupConfig.getRetryQueueNums() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">    response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成重试topic名</span></span><br><span class="line">  String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</span><br><span class="line">  <span class="keyword">int</span> queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> topicSysFlag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (requestHeader.isUnitMode()) &#123;</span><br><span class="line">    topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询（或创建）重试队列topic</span></span><br><span class="line">  TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(</span><br><span class="line">    newTopic,</span><br><span class="line">    subscriptionGroupConfig.getRetryQueueNums(),</span><br><span class="line">    PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</span><br><span class="line">  ......</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 记录msg的原topic</span></span><br><span class="line">  <span class="keyword">final</span> String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == retryTopic) &#123;</span><br><span class="line">    MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</span><br><span class="line">  &#125;</span><br><span class="line">  msgExt.setWaitStoreMsgOK(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line">	......</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果消息已经重试的次数大于最大重试次数（来源于订阅信息），那么直接发到死信队列</span></span><br><span class="line">  <span class="comment">// 顺序消费的情况下，因为在本地重试直到超出最大次数，所以发回broker的消息均满足该条件，直接进入死信队列(DLQ)</span></span><br><span class="line">  <span class="comment">// 并发消费+集群模式下，可能进入死信队列，可能进入重试队列</span></span><br><span class="line">  <span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes</span><br><span class="line">      || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">    queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">    topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic,</span><br><span class="line">                                                                                                   DLQ_NUMS_PER_GROUP,</span><br><span class="line">                                                                                                   PermName.PERM_WRITE, <span class="number">0</span></span><br><span class="line">                                                                                                  );</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">      response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">      response.setRemark(<span class="string">&quot;topic[&quot;</span> + newTopic + <span class="string">&quot;] not exist&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 与延迟相关的属性，将会使消息在一段时间后才能消费，下一节介绍</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">      delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 写入消息</span></span><br><span class="line">  PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="23-消费失败重试总结">2.3、消费失败重试总结</span></h3><table>
<thead>
<tr>
<th>消费类型</th>
<th>重试方式</th>
<th>发回Broker重新消费</th>
</tr>
</thead>
<tbody><tr>
<td>顺序消费</td>
<td>本地重试</td>
<td>发回Broker时直接进入死信队列，不再消费到</td>
</tr>
<tr>
<td>批量消费-广播</td>
<td>忽略</td>
<td>无</td>
</tr>
<tr>
<td>批量消费-集群</td>
<td>本地不重试</td>
<td>发回Broker时根据重试次数，可能进入重试队列并重新消费</td>
</tr>
</tbody></table>
<h2><span id="3-延迟消息">3、延迟消息</span></h2><p>某些业务场景不希望生产的消息立即被消费，RocketMQ在一定程度上支持延迟消息。</p>
<h3><span id="31-延迟队列">3.1、延迟队列</span></h3><p>在RocketMQ在Broker端存在一个SCHEDULE_TOPIC_XXXXtopic，其下有18个队列，分别对应不同的延迟时间，也即是RocketMQ原生只支持预设的18个阈值的延迟消息。</p>
<p>使用方式为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// level范围为&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;对应的索引</span></span><br><span class="line">msg.setDelayTimeLevel(<span class="keyword">int</span> level);</span><br></pre></td></tr></table></figure>
<h3><span id="32-broker端对延迟消息的处理">3.2、Broker端对延迟消息的处理</span></h3><p>在存储的时候，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.store.CommitLog</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">        msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">      queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">      MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">      MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">      msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">      msg.setTopic(topic);</span><br><span class="line">      msg.setQueueId(queueId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果消息设置了DelayLevel，那么消息真实的topic及queue会被保存到properties中，而消息将会被存储至SCHEDULE_TOPIC_XXXX中对应delayLeve的队列里。</p>
<p>同时Broker需要对队列中的消息进行调度，相关逻辑如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.store.schedule.ScheduleMessageService</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeliverDelayedMessageTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> delayLevel;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DeliverDelayedMessageTimerTask</span><span class="params">(<span class="keyword">int</span> delayLevel, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.delayLevel = delayLevel;</span><br><span class="line">            <span class="keyword">this</span>.offset = offset;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isStarted()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.executeOnTimeup();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  ......</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeOnTimeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 获取delayLevel对应的消费队列</span></span><br><span class="line">            ConsumeQueue cq =</span><br><span class="line">           ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,</span><br><span class="line">                    delayLevel2QueueId(delayLevel));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> failScheduleOffset = offset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cq != <span class="keyword">null</span>) &#123;</span><br><span class="line">                SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</span><br><span class="line">                <span class="keyword">if</span> (bufferCQ != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> nextOffset = offset;</span><br><span class="line">                        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                        ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">                      <span class="comment">// 遍历消费队列</span></span><br><span class="line">                        <span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                            ......</span><br><span class="line">                              <span class="comment">// 计算出消息应该被投递的时间，这里小于0是符合投递条件</span></span><br><span class="line">                            <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                MessageExt msgExt =</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">                                        offsetPy, sizePy);</span><br><span class="line"></span><br><span class="line">                               ......</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="comment">// 不符合投递条件（时间不到），则等待间隔后执行 </span></span><br><span class="line">                                ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">                                    <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel, nextOffset),</span><br><span class="line">                                    countdown);</span><br><span class="line">                                ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="comment">// end of for</span></span><br><span class="line"></span><br><span class="line">                       ......</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                        bufferCQ.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// end of if (bufferCQ != null)</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 没有消息，等待下次</span></span><br><span class="line">									......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end of if (cq != null)</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">  ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对应每个delayLevel存在一个定时任务，存在一个定时任务，读取对应的队列，将到期的消息发送到原队列中以供消费。定时任务的初始化位于DefaultMessageStore中。</p>
<h3><span id="33-支持任意时间延迟的设想">3.3、支持任意时间延迟的设想</span></h3><p>很容易想到时间轮算法，然而RocketMQ并不是时间轮算法一个较好的承载体：或者大量时间刻度导致创建大量的队列、或者频繁的遍历引起较高的IO。</p>
<p>但可以尝试结合时间轮与当前固定队列的方式，仅实现一个分钟内（秒级时间轮），同时为消息增加一个属性，能够将消息的精确时间组合为多次延迟队列+秒级时间轮。</p>
<p>例如现在有1mins、5mins两个延迟队列及一个60s（刻度1s）的时间轮，如果有一条定时17min22s的消息，我们可以令这条消息经历三次5mins的延迟队列，同时经历两次1mins的延迟队列，最后再落入时间轮22s的刻度中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/01/01/The_Git_Way_to_Use_Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Terrell Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/01/The_Git_Way_to_Use_Git/" class="post-title-link" itemprop="url">持续集成Git使用指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-01T00:00:00+08:00">2019-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-22 21:47:40" itemprop="dateModified" datetime="2020-12-22T21:47:40+08:00">2020-12-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>发布系统Git使用指南</p>
<p>——the Git Way to Use Git</p>
<!-- toc -->

<ul>
<li><a href="#%E8%83%8C%E6%99%AF">背景</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%A0%81">获取代码</a><ul>
<li><a href="#%E4%BB%93%E5%BA%93">仓库</a></li>
<li><a href="#%E5%88%86%E6%94%AF">分支</a></li>
<li><a href="#%E5%A4%9A%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90">多分支集成</a></li>
<li><a href="#commit-id">Commit ID</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E6%9C%AC%E8%8A%82%E5%9B%9E%E9%A1%BE">本节回顾</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%9F%BA%E7%BA%BF">代码基线</a><ul>
<li><a href="#%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E4%B8%BB%E5%B9%B2">检查代码合并主干</a></li>
<li><a href="#%E5%90%91%E4%B8%BB%E5%B9%B2%E5%90%88%E5%B9%B6tag">向主干合并&amp;Tag</a></li>
</ul>
</li>
<li><a href="#%E6%8F%90%E7%A4%BA%E6%80%BB%E7%BB%93">提示&amp;总结</a></li>
</ul>
<!-- tocstop -->

<h3><span id="背景">背景</span></h3><p>​    有文章曾归纳，Git是一套内容寻址文件系统，意思是，Git的核心是存储键值对^[1]^。显然，这样的形式不利于普通人类使用。</p>
<p>       通常情况下我们使用的Git命令，都被称作高级命令（例如pull、merge等），区别于底层的低级命令，两种命令分别对应于Git文档中出现Porcelain、Plumbing（第一次在文档见到这些词有没有很困惑！）。</p>
<p>       高级命令大都有易读参数与翔实输出，可以认为是由低级命令封装，方便人使用。那么低级命令存在的意义是？</p>
<p>       根据文档的描述^[2]^，低级命令的接口相较高级命令，更加稳定。低级指令本身就是为脚本使用而存在的，便于确切的输入参数并精准的识别输出。那么，在发布系统中合理使用低级命令替代高级命令，无疑将会使设计的逻辑更加准确的执行。</p>
<p>       以下，根据微店发布系统的实际场景和经验，从两个方面总结一下如何利用更恰当的Git命令，实现较完备的代码操作流程。</p>
<h3><span id="获取代码">获取代码</span></h3><p>       代码获取的大致逻辑分为四个层级：确定仓库、确定分支、确定Commit ID、确定目录</p>
<h4><span id="仓库">仓库</span></h4><p>       确定仓库地址之前，首先需要当前工作目录是否是一个Git仓库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-learn&gt; git rev-parse --is-inside-work-tree</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>​    确认当前工作目录的仓库地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-learn&gt; git config --list|grep -F <span class="string">&quot;remote.origin.url&quot;</span></span><br><span class="line">remote.origin.url=ssh://git@gitlab.xxx/chentairan/git-learn.git</span><br></pre></td></tr></table></figure>
<p>​    如果需要直接设置仓库地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-learn&gt; git config remote.origin.url ssh://git@gitlab.xxx/chentairan/git-learn.git</span><br></pre></td></tr></table></figure>
<h4><span id="分支">分支</span></h4><p>​    获取指定远程分支</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-learn&gt; git fetch ssh://git@gitlab.xxx/chentairan/git-learn.git $BRANCH_NAME:refs/remotes/origin/$BRANCH_NAME</span><br><span class="line">remote: Counting objects: 6, done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (6/6), done.</span><br><span class="line">From ssh://gitlab.xxx/chentairan/git-learn</span><br><span class="line"> * [new branch]      dev        -&gt; origin/dev</span><br></pre></td></tr></table></figure>
<p>​    获取分支的Commit ID</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-learn&gt; git rev-parse --verify refs/remotes/origin/$BRANCH_NAME</span><br><span class="line">9e100c01201678286db5d266b8d342b0dd8a8e0d</span><br></pre></td></tr></table></figure>
<p>​    检出提交</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-learn&gt; git checkout -f 9e100c01201678286db5d266b8d342b0dd8a8e0d</span><br></pre></td></tr></table></figure>
<p>​    去掉多余文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-learn&gt; git clean -fdx</span><br></pre></td></tr></table></figure>
<h4><span id="多分支集成">多分支集成</span></h4><p>​    在同时有多个RD一起开发的项目中，总会遇到有多个分支需要同时上线的情况（对应多个需求或者同一需求的不同工作部分）。通常的做法是从主干上拉出一个临时分支，将各开发分支的变更全部合并</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-temp&gt; git fetch origin master:refs/remotes/origin/master $BRANCH_DEV1:refs/remotes/origin/$BRANCH_DEV1 $BRANCH_DEV2:refs/remotes/origin/$BRANCH_DEV2</span><br><span class="line">...</span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; git checkout origin/master</span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; git merge --no-edit --strategy=octopus origin/$BRANCH_DEV1 origin/$BRANCH_DEV2 ...</span><br></pre></td></tr></table></figure>
<p>​    如果没有冲突，那么多分支的检出就完成了</p>
<h4><span id="commit-id">Commit ID</span></h4><p>​    如果发布时需要检出某指定提交，而不是某分支的最新提交（比如生产环境发布的代码，一定要是测试环境测试通过的代码版本），那么在fetch远程分支之后，直接检出对应提交</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-temp&gt; git checkout -f $COMMIT_ID</span><br></pre></td></tr></table></figure>
<h4><span id="目录">目录</span></h4><p>​    需要集成的项目代码可能不在项目根目录，而在项目下某一目录中，在使用<code>pushd $TARGET_DIRECTORY</code>之后，可能需要检查当前所在目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-temp&gt; pushd target_dir</span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; git rev-parse --show-prefix</span><br><span class="line">target_dir/</span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; popd</span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; git rev-parse --show-prefix</span><br><span class="line"></span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; </span><br></pre></td></tr></table></figure>
<h4><span id="本节回顾">本节回顾</span></h4><p><code>git rev-parse</code>用于查看参数，返回结果通常可以直接使用不需额外处理    </p>
<p><code>git config</code>用于配置、查看参数，绕过了<code>git remote</code>命令可能存在的报错</p>
<p><code>git fetch</code>用于拉取分支，并不改变当前工作区内容，相比<code>git pull</code>更加精确有效</p>
<p><code>git checkout</code>用于检出提交，但对于缓存区文件（也许上次集成生成的问题）以及.gitignore中配置的文件不做处理</p>
<p><code>git clean</code>用于清理工作区，仅留下指定提交下面关联的文件</p>
<p><code>git merge --no-edit --strategy=octopus</code>用于合并多个分支，–no-edit参数使得CommitMessage不需要编辑，octopus是默认的Merge策略，在遇到复杂合并操作，需要人工解决时，拒绝合并</p>
<h3><span id="代码基线">代码基线</span></h3><p>​    基线管理简单说就两件事：确保开发代码包含代码主干的最新提交，确保代码主干有稳定版本可追溯。再说细一点：发布时检查代码是否合并了主干的最新提交，也即是最新的上线代码；线上发布完成之后，代码合并至主干，并打Tag。</p>
<h4><span id="检查代码合并主干">检查代码合并主干</span></h4><p>​    检查是否合并了主干最新提交，通常有两种实现方式：一是在开发提交代码时，Git通过Hook配置检查；二是在发布系统这里，发布前做检查。方法一后续会写一篇文章专门讲Hook的能干的事情，本文主要介绍方法二。</p>
<p>​    查看代码主干位置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-temp&gt; git ls-remote origin refs/heads/master</span><br><span class="line">1297bb993557e8b58b37abc3dbb315402f95f349	refs/heads/master</span><br></pre></td></tr></table></figure>
<p>​    查看开发代码是否包含此次提交历史</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chentairan@localhost ~/t/git-temp&gt; git rev-list $COMMIT_ID</span><br><span class="line">......</span><br><span class="line">f19d66e5a154e3b7415b36d55d6cdd9c3648261d</span><br><span class="line">9e100c01201678286db5d266b8d342b0dd8a8e0d</span><br><span class="line">1297bb993557e8b58b37abc3dbb315402f95f349</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>​    此处可以通过grep检查是否包含主干的最新提交</p>
<h4><span id="向主干合并amptag">向主干合并&amp;Tag</span></h4><p>​    由于开发的代码包含了主干的最新提交，那么向主干合并时，只是一个向前走的过程，一定不会有冲突，所以直接使用merge进行合并</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...如第一部分拉取发布分支...</span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; git checkout origin/master</span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; git merge $COMMIT_ID --no-ff -m &quot;$SOME_MESSAGE&quot;</span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; git tag $TAG_INFO -m &quot;Create production tag&quot;</span><br><span class="line">chentairan@localhost ~/t/git-temp&gt; git push origin HEAD:refs/heads/master --tags</span><br></pre></td></tr></table></figure>
<p>####本节回顾    </p>
<p><code>git ls-remote</code>用于查看远程代码仓库上主干分支的位置</p>
<p><code>git rev-list</code>用于查看某次提交之前的历史</p>
<p><code>git merge --no-ff</code> 用于合并代码。根据健康的Git工作流，所有的开发提交合并至主干时都是fast-forward过程。–no-ff参数能使fast-forward也产生一个新的Merge Commit（无此参数则不会），目的是保持开发分支的开发记录，保持整个代码开发历史的完整性</p>
<p><code>git tag</code>用于新建Tag，保存线上稳定版本</p>
<p><code>git push origin HEAD:refs/heads/master --tags</code>用于提交Merge后的代码及Tag。使用origin/master拉取代码，并使用HEAD:refs/heads/master方式提交，相比切换至本地master分支再更新、合并、提交，步骤更简单，并绕过本地master分支可能存在的需要处理的变更</p>
<h3><span id="提示amp总结">提示&amp;总结</span></h3><p>​    发布系统的准确性直接影响线上稳定性，准确性的首要任务是确保异常产物无法上线</p>
<p>​    所有的命令均可以通过Shell的$?进行判错，有异常一定终止流程，人工介入，尽量避免使用–force参数</p>
<p>​    所有的命令以准确性为首要目标，脚本中所有的Git指令，能尽可能全面地指定参数，则尽量全面（曾经遇到过使用Git关键字作为分支名，导致的异常问题，Git偶尔会混淆在命令中该参数的具体含义指代。PS：不规范的名字可以在提交前通过Hook进行检查）</p>
<p>参考文献</p>
<p>[1]<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1">https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1</a></p>
<p>[2] <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/git.1.html">http://man7.org/linux/man-pages/man1/git.1.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Terrell Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        


  <script src='https://unpkg.com/mermaid@8.8.4/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Terrell Chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
